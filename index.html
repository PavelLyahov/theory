<!DOCTYPE html>
<html>
<title>Теория для автотестера</title>
<link href="css/style.css" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body class="container element">

  <select id="dropdown" onchange="showContent()">
    <option value="block-1">Java</option>
    <option value="block-2">Testing theory</option>
    <option value="block-3">Шаблоны, Patterns</option>
    <option value="block-4">HTML, API</option>
    <option value="block-5">БД, SQL, JDBC</option>
    <option value="block-6">Git</option>
    <option value="block-7">JavaScript</option>
    <option value="block-8">Selenium</option>
    <option value="block-9">Efficient proframming</option>
  </select>

  <div id="block-1" class="block content active">

    <div class="block">ООП

      <div class="content">

        <div class="nested-block">ООП
          <div class="nested-content">
            <p>Объектно-ориентированное программирование (ООП) —
              методология программирования, основанная на представлении программы
              в виде совокупности объектов, каждый из которых является экземпляром
              определенного класса, а классы образуют иерархию наследования.</p>
            </p>
          </div>
        </div>

        <div class="nested-block">Полиморфизм
          <div class="nested-content">
            <p>это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
              структуре объекта.</p>
            <p>1 ad-hoc - перегрузка (имена методов одинаковые, а типы принимаемых аргументов разные)</p>
            <p>2 параметрический - дженерики</p>
            <p>3 полиморфизм подтипов, достигается с помощью наследование и обкаста
              это переопределение - позднее связывание</p>
          </div>
        </div>

        <div class="nested-block">В чем разница между композицией и агрегацией?
          <div class="nested-content">
            <p>Композиция и агрегация — частные случаи ассоциации «часть-целое»</p>
            <p>Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть).
              Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие,
              что экземпляр «части» может входить только в одно целое (или никуда не входить),
              в то время как в случае агрегации экземпляр «части» может входить в несколько целых.</p>
          </div>
        </div>

        <div class="nested-block">Позднее связывание
          <div class="nested-content">
            <p>сли связывание проводится компилятором (компоновщиком) перед запуском программы,
              то оно называется статическим или ранним связыванием (early binding).</p>
            <p>Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime
              binding). </p>
            <p>Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был
              объявлен
              как final, static или private (приватные методы являются final по умолчанию).</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">JVM

      <div class="content">

        <div class="nested-block">За что отвечает JVM
          <div class="nested-content">
            <p>Загрузка, проверка и исполнение байт кода;</p>
            <p> Предоставление среды выполнения для выполнения байт-кода;</p>
            <p> Управление памятью и очисткой мусора (Garbage collectio</p>
          </div>
        </div>

        <div class="nested-block">Classloader
          <div class="nested-content">
            <p>Это часть JRE, которая динамически загружает Java классы в JVM
              «по требованию», она не происходит до тех пор, пока программа не вызовет класс
              Класс с именем может быть загружен только один раз данным загрузчиком классов..</p>
            <p>
              Bootstrap class loader загружает основные библиотеки Java, JAVA_HOME/jre/lib.
              Этот загрузчик является частью ядра JVM, написан на нативном коде.
            </p>
            <p>
              Extensions class loader загружает код в каталоги расширений
              (JAVA_HOME/jre/lib/ext, или любой другой каталог, указанный системным свойством java.ext.dirs).
            </p>
            <p>
              System class loader загружает код, найденный в java.class.path,
              который сопоставляется с переменной среды CLASSPATH.
            </p>
          </div>
        </div>

        <div class="nested-block">Области данных
          <div class="nested-content">
            <p>Каждый поток в JVM имеет собственный стек</p>
            <p>heap (кучу), используется всеми потоками виртуальной машины Java.
              Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов
              классов.
              Куча создается при запуске виртуальной машины. </p>
            <p>The pc Register (PCR) Коротко говоря: для одного потока, существует один PCR, который создается при
              запуске потока.
              PCR хранит адрес выполняемой сейчас инструкции JVM.</p>
            <p>Method Area является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул
              констант,
              данные полей и методов, а также код для методов и конструкторов, включая специальные методы,
              используемые при инициализации классов и экземпляров, и инициализации интерфейса. </p>
            <p>
              Method Area хранятся все классы и статические переменные.
              Это включает информацию о структуре класса, методах, полях, интерфейсах, а также другие метаданные.
              Он является общим для всех потоков выполнения и используется для хранения информации о классах, которые
              были загружены в JVM.
            </p>
            <p>
              Native Method Stacks (Стеки нативных методов):
              Как и у Java-потоков, каждый нативный метод (написанный на языках, отличных от Java,
              и вызываемый через JNI) имеет свой собственный стек нативного метода.
              Этот стек используется для хранения локальных переменных и информации о вызовах нативных методов.
            </p>
          </div>
        </div>

        <div class="nested-block">Frames
          <div class="nested-content">
            <p>Frame используется для хранения данных и частичных результатов, а также для выполнения динамического
              связывания,
              возврата значений и отправки исключений. Новый frame создается каждый раз, когда вызывается метод.
              и уничтожается, когда завершается вызов метода</p>
          </div>
        </div>
      </div>
    </div>

    <div class="block">CORE

      <div class="content">

        <div class="nested-block">интерфейс
          <div class="nested-content">
            <p>Интерфейсы в Java - это механизм, который позволяет определить абстрактный тип данных,
              состоящий только из сигнатур методов и константных полей, но без их реализации</p>
            <p>Абстрактные методы: должны быть реализованы классами, которые реализуют интерфейс.</p>
            <p>Константные поля: автоматически считаются public, static и final.</p>
            <p>public и abstract методы: автоматически, модификаторы можно опустить</p>
            <p>Java 8: (default methods) + (static methods)</p>
            <p>Java 9: private methods</p>
            <p>Java 11: private static methods</p>
          </div>
        </div>

        <div class="nested-block">абстрактный класс VS интерфейс
          <div class="nested-content">
            <p>Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является).
              Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</p>
            <p>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для
              частичной реализации поведения.
              Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности</p>
          </div>
        </div>

        <div class="nested-block">порядок вызова конструкторов и блоков инициализации
          <div class="nested-content">
            <p>Parent static block(s) → Child static block(s) </p>
            <p>Parent non-static block(s) → Parent constructor</p>
            <p> Child non-static block(s) → Child constructor</p>
          </div>
        </div>

        <div class="nested-block">Nested (Вложенные классы)
          <div class="nested-content">
            <p>Вложенные статические классы объявляются с ключевым словом static и, как следствие,
              не имеют доступа к нестатическим членам (полей и методам) внешнего класса.
              Использоваться, когда логически связанный класс нужно скрыть внутри внешнего класса.</p>
            <p>Внутренние классы (Inner Classes): имеют доступ к нестатическим членам внешнего класса, включая его
              приватные члены.
              Они имеют доступ к своему внешнему экземпляру, что позволяет установить более тесную связь с внешним
              классом.
              Внутренние классы бывают:</p>
            <p>Анонимные классы (Anonymous Classes): создаются без явного объявления имени класса.
              Они обычно используются для создания одноразовых экземпляров класса, который реализует интерфейс или
              расширяет абстрактный класс.</p>
            <p>Локальные классы (Local Classes) объявляются внутри блоков кода (например, методов) и имеют доступ к
              локальным переменным этого блока кода.
              Они обычно используются для создания классов, которые должны быть видны только внутри ограниченной области
              их объявления.</p>
          </div>
        </div>

        <div class="nested-block">переменные в методы, по значению или по ссылке?
          <div class="nested-content">
            <p>«скопировать значение и передать копию». С примитивами это будет копия содержимого.
              Со ссылками - тоже копия содержимого, т.е. копия ссылки.</p>
          </div>
        </div>

        <div class="nested-block">final, finally и finalize()?
          <div class="nested-content">
            <p>Модификатор final:</p>
            <p>Класс не может иметь наследников;</p>
            <p>Метод не может быть переопределен в классах наследниках;</p>
            <p>Поле не может изменить свое значение после инициализации;</p>
            <p>Локальные переменные не могут быть изменены после присвоения им значения;</p>
            <p>Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от того,
              какие исключения были возбуждены и перехвачены в блоке try-catch.</p>
            <p>Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>
          </div>
        </div>

        <div class="nested-block">приведение типов.
          <div class="nested-content">
            <p>Расширение (повышение, upcasting) примитивного типа (widening primitive).</p>
            <p> Означает, что осуществляется переход от менее емкого типа к более ёмкому.
              byte -> int (длина 4 байта).</p>
            <p>Сужение (понижение, downcasting) примитивного типа (narrowing primitive</p>
            <p>Расширение объектного типа (widening reference)</p>
            <p> переход от потомка к предку. Разрешено всегда и происходит автоматически.</p>
            <p> Возможно только если исходная переменная является подтипом приводимого типа.
              При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.
              Требует явного указания типа.</p>
          </div>
        </div>

        <div class="nested-block">autoboxing («автоупаковка»)
          <div class="nested-content">
            <p>Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long,
              Float, Double, Character, Boolean)
              значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования
              конструктора класса.</p>
          </div>
        </div>

        <div class="nested-block">Object
          <div class="nested-content">
            <p> equals(Object obj) для сравнения объектов по значению;</p>
            <p>hashCode() – возвращает hash код для объекта;</p>
            <p>toString() – возвращает строковое представление объекта;</p>
            <p>getClass() – возвращает класс объекта во время выполнения;</p>
            <p>clone() – создает и возвращает копию объекта;</p>
            <p>notify() – возобновляет поток, ожидающий монитор;</p>
            <p>notifyAll() – возобновляет все потоки, ожидающие монитор;</p>
            <p>ait() – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify()
              или notifyAll() для этого объекта;</p>
            <p>finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
          </div>
        </div>

        <div class="nested-block">Переопределение equals():
          <div class="nested-content">
            <p>на равенство ссылок (this == obj).
              Если объекты ссылаются на одну и ту же область памяти, они должны считаться равными. </p>
            <p>Проверка на тип объекта</p>
            <p>Сравнивайте значения всех полей</p>
            <p>if (this == obj) return true;
              if (obj == null || getClass() != obj.getClass()) return false;
              MyClass other = (MyClass) obj;
              return field1 == other.field1 &&
              Objects.equals(field2, other.field2) &&
              Objects.equals(field3, other.field3);</p>
          </div>
        </div>

        <div class="nested-block">Переопределение hashCode():
          <div class="nested-content">
            <p>@Override
              public int hashCode() {
              return Objects.hash(field1, field2, field3);
              }</p>
          </div>
        </div>

        <div class="nested-block">EXCEPTIONS иерархия
          <div class="nested-content">
            <p>общий предок — класс Throwable</p>
            <p>Exception (stackOverflow) и Error (OutOfMemoryError, StackOwerflow)</p>
            <p>Exception имеет предков runtime (Unchecked) (ClassCastException, IndexOutOfBoundsException,
              NoSuchElementException)
              и различных checked (IOException)</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>



      </div>
    </div>

    <div class="block">String

      <div class="content">

        <div class="nested-block">Почему строка является популярным ключом в HashMap в Java?
          <div class="nested-content">
            <p>Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания,
              не требуя повторного пересчета при дальнейшем использовании.
              Поэтому в качестве ключа HashMap они будут обрабатываться быстрее.</p>
          </div>
        </div>

        <div class="nested-block">разница между String, StringBuffer, StringBuilder?
          <div class="nested-content">
            <p>Класс String является неизменяемым (immutable) -
              модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</p>
            <p>StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать
              содержимое</p>
            <p>StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того,
              что он не синхронизирован и поэтому его методы выполняются значительно быстрей.</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">COLLECTIONS

      <div class="content">

        <div class="nested-block">основные интерфейсы
          <div class="nested-content">
            <p>«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть
              числа, строки, объекты пользовательских классов и т.п</p>
            <p>Интерфейс Collection расширяют интерфейсы:</p>

            <ul>List (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Реализации</ul>
            <li>ArrayList - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при
              добавлении новых элементов.
              Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.</li>
            <li>LinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как
              собственно данные,
              так и две ссылки на следующий и предыдущий узел.</li>
            <li>Vector — реализация динамического массива объектов, методы которой синхронизированы.</li>
            <ul>Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:</ul>
            <li>HashSet - использует HashMap для хранения данных. В качестве ключа используется добавляемый элемент,
              в качестве значения - заглушка Object.
              Из-за особенностей реализации порядок элементов не гарантируется при добавлении.</li>
            <li>LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку
              добавления элементов.</li>
            <li>TreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта
              Comparator, либо сохраняет элементы с использованием «natural ordering».
              <ul>Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения
                FIFO (first-in-first-out):</ul>
            <li>PriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта
              Comparator,
              либо сохраняет элементы с использованием «natural ordering».</li>
            <li>ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами,
              позволяющими реализовать конструкцию вида LIFO last-in-first-out</li>
            <li></li>

            <p>Интерфейс Map реализован классами:</p>
            <li>Hashtable — хэш-таблица, методы которой синхронизированы.
              Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.</li>
            <li>HashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является
              упорядоченной.</li>
            <li>LinkedHashMap — упорядоченная реализация хэш-таблицы.</li>
            <li>TreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет
              возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
              либо сохраняет элементы с использованием «natural ordering».</li>
          </div>
        </div>

        <div class="nested-block">Как между собой связаны Iterable и Iterator?
          <div class="nested-content">
            <p>Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.</p>
          </div>
        </div>

        <div class="nested-block">Как поведёт себя коллекция, если вызвать iterator.remove()?
          <div class="nested-content">
            <p>Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент
              коллекции,
              на который указывает итератор, в противном случае будет выброшено IllegalStateException().</p>
          </div>
        </div>

        <div class="nested-block">Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в
          каких второй?
          <div class="nested-content">
            <ul>ArrayList:</ul>
            <li>доступ к произвольному элементу по индексу за константное время O(1);</li>
            <li>доступ к элементам по значению за линейное время O(N);</li>
            <li>вставка в конец в среднем производится за константное время O(1);</li>
            <li>удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы,
              находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
            </li>
            <li>вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы,
              находящиеся «правее» смещаются на одну ячейку вправо;</li>
            <li>минимум накладных расходов при хранении.</li>
            <ul>LinkedList:</ul>
            <li>на получение элемента по индексу или значению потребуется линейное время O(N);</li>
            <li>но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1)
              — ссылки постоянно хранятся на первый и последний элемент;</li>
            <li>на добавление и удаление в начало или конец списка потребуется константное O(1);</li>
            <li>вставка или удаление в/из произвольного место константное O(1);</li>
            <li>но поиск позиции вставки и удаления за линейное время O(N);</li>
            <li>требует больше памяти для хранения такого же количества элементов,
              потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</li>
          </div>
        </div>

        <div class="nested-block">HashMap принцип работы
          <div class="nested-content">
            <p>Принцип работы HashMap:</p>

            <ul>1. Хеширование ключей </ul>
            <li>Когда вы добавляете элемент в HashMap с помощью метода put(key, value), сначала вычисляется хеш-код
              ключа key с помощью метода hashCode() объекта ключа
              Затем вычисляется индекс массива, в который будет помещен элемент.</li>

            <ul>2. поиск индекса:</ul>
            <li>Если в результате корзина занята (т.е. произошла коллизия),
              Ключи сверяются по equals (если равны - перезаписывается значение, если нет -
              произошла коллизия

              <ul>3. Разрешение коллизий:</ul>
            <li> новый элемент добавляется в конец связанного списка (цепочки) для этой корзины. В Java 8 и выше, когда
              коллизии часто возникают,
              вместо списка может использоваться бинарное дерево для улучшения производительности поиска.</li>

            <ul>Динамическое изменение размера:</ul>
            <li>После добавления элемента, HashMap проверяет, не превышает ли количество элементов в коллекции
              определенное значение, которое связано с фактором загрузки (load factor)
              количество элементов / размер массива (обычно от 0.5 до 0.75).
              Когда количество элементов в одной корзине превышает определенный предел (обычно 8),
              Java (8+) преобразует связанный список в бинарное дерево.
            </li>
          </div>
        </div>

        <div class="nested-block">HashСode
          <div class="nested-content">
            <p>- метод Object, возвращает 32-битовое значение.
              Рассчитывается hashCode() по умолчанию на основе адреса объекта в памяти,
              Важно переопределить метод hashCode() для классов, используемых в качестве ключей в HashMap.
              Когда объекты равны с точки зрения equals(),
              их хеш-коды должны быть одинаковыми, чтобы они попали в одну и ту же корзину в хеш-таблице.
            </p>
          </div>
        </div>

        <div class="nested-block">Бинарное дерево (Binary Tree)
          <div class="nested-content">
            <p>это структура данных, состоящая из узлов, где каждый узел содержит три элемента: значение (ключ), левого
              потомка и правого потомка. Каждый узел в бинарном дереве имеет не более двух потомков:
              левого потомка и правого потомка, которые, в свою очередь, также могут быть бинарными деревьями.</p>
            <p>Преимущества бинарного дерева над связанным списком заключаются в том, что время поиска элемента в дереве
              логарифмическое, O(log n), вместо линейного, O(n), как в связанном списке</p>

          </div>
        </div>

        <div class="nested-block">LinkedHashMap
          <div class="nested-content">
            <p>Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка,
              определяющего порядок итерации по элементам структуры данных.
              По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order).
              Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true.
              В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order).
              Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец
              списка.</p>
          </div>
        </div>

        <div class="nested-block">Как перебрать все ключи \ значения Map?
          <div class="nested-content">
            <p>Использовать метод keySet(), который возвращает множество Set<K> ключей.</p>
            <p>Использовать метод values(), который возвращает коллекцию Collection<V> значений.</p>
          </div>
        </div>

        <div class="nested-block">Как перебрать все пары «ключ-значение» в Map?
          <div class="nested-content">
            <p>for (Map.Entry<String, Integer> entry : map.entrySet()) </p>
            <p> String key = entry.getKey();</p>
            <p>Integer value = entry.getValue();</p>
          </div>
        </div>


        <div class="nested-block">В чем отличия TreeSet и HashSet?
          <div class="nested-content">
            <p>TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.
              Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).</p>
            <p>HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием,
              что в HashSet в качестве ключа и значения выступает сам элемент, кроме того, HashSet не поддерживает
              упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично
              HashMap.</p>
          </div>
        </div>


        <div class="nested-block">Как получить коллекцию только для чтения?
          <div class="nested-content">
            <p>Collections.unmodifiableList(list);</p>
            <p>Collections.unmodifiableSet(set);</p>
            <p>Collections.unmodifiableMap(map).</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Java 8

      <div class="content">

        <div class="nested-block">Лямбда выражения
          <div class="nested-content">
            <p> Лямбда-выражения представляют собой компактный способ представления анонимных функций,
              которые могут быть использованы в качестве аргументов методов или возвращаемых значений.</p>
            <p>Function<Integer, Integer> square = x -> x * x;</p>
            <p>BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;</p>
            <p>Лямбда-выражения часто используются вместе с функциональными интерфейсами, такими как Runnable, Consumer,
              Predicate, Function и другими, которые определены в пакете java.util.function.
              Эти интерфейсы предоставляют предопределенные абстрактные методы, которые могут быть реализованы с помощью
              лямбда-выражений</p>


            <p>Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->.
              Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения,
              а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.
            </p>
            <p>interface Operationable {</p>
            <p>int calculate(int x, int y); }</p>
            <p>public static void main(String[] args) {</p>
            <p>Operationable operation = (x, y) -> x + y; </p>
            <p>int result = operation.calculate(10, 20);}</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Что такое «ссылка на метод»?
          <div class="nested-content">
            <p>имя_класса::имя_статического_метода для статического метода;</p>
            <p>объект_класса::имя_метода для метода экземпляра;</p>
            <p>название_класса::new для конструктора.</p>
            <p>Measurable a = String::length;</p>
          </div>
        </div>

        <div class="nested-block">Что такое «функциональные интерфейсы»?
          <div class="nested-content">
            <p>Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.</p>
            <p>Чтобы точно определить интерфейс как функциональный, добавлена аннотация @FunctionalInterface, работающая
              по принципу @Override.
              Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.</p>
            <p>Интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что
              default методы - не абстрактные.</p>
          </div>
        </div>

        <div class="nested-block">функциональные интерфейсы Function<T,R>, UnaryOperator<T>?
              <div class="nested-content">
                <p>Function<T,R> интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса
                    T и возвращающая на выходе экземпляр класса R.</p>
                <p>Function<String, Integer> toInteger = Integer::valueOf;</p>
                <p>UnaryOperator<T>(унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними
                    операции и возвращает результат операций в виде объекта типа T:</p>
                <p>UnaryOperator<Integer> operator = x -> x * x;</p>
                <p>BinaryOperator<T>- интерфейс, с помощью которого реализуется функция, получающая на вход два
                    экземпляра класса T и возвращающая на выходе экземпляр класса T.</p>
                <p>BinaryOperator<Integer> operator = (a, b) -> a + b;</p>
                <p>Predicate<T>интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T
                    и возвращающая на выходе значение типа boolean.</p>
                <p>Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or,
                  negate).</p>
                <p>Predicate<String> predicate = (s) -> s.length() > 0;</p>
                <p>Consumer<T> (потребитель) - интерфейс, с помощью которого реализуется функция, которая получает на
                    вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает.</p>
                <p>Consumer<String> hello = (name) -> System.out.println("Hello, " + name);</p>
                <p>Supplier<T> (поставщик) - интерфейс, с помощью которого реализуется функция, ничего не принимающая на
                    вход, но возвращающая на выход результат класса T;</p>
                <p>Supplier<LocalDateTime> now = LocalDateTime::now;</p>
              </div>
        </div>

        <div class="nested-block">Что такое Stream?
          <div class="nested-content">
            <p>последовательность элементов, над которой можно производить промежуточные (intermediate) или конечные
              (terminal). операции.</p>
            <p>Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же
              стрим.</p>
            <p>Стримы создаются на основе каких-либо источников, например классов из java.util.Collection</p>
          </div>
        </div>

        <div class="nested-block">способы создания стрима?
          <div class="nested-content">
            <p>Из коллекции:</p>
            <p>Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();</p>
            <p>Из набора значений:</p>
            <p>Stream<String> fromValues = Stream.of("x", "y", "z");</p>
            <p>Из массива:</p>
            <p>Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});</p>
            <p>Из файла (каждая строка в файле будет отдельным элементом в стриме):</p>
            <p>Stream<String> fromFile = Files.lines(Paths.get("input.txt"));</p>
            <p>Из строки:</p>
            <p>IntStream fromString = "0123456789".chars();</p>
            <p>С помощью Stream.builder():</p>
            <p>Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();</p>
            <p>С помощью Stream.iterate() (бесконечный):</p>
            <p>Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);</p>
            <p>С помощью Stream.generate() (бесконечный):</p>
            <p>Stream<String> fromGenerate = Stream.generate(() -> "0");</p>
          </div>
        </div>

        <div class="nested-block"> промежуточные методы
          <div class="nested-content">
            <p>findFirst() возвращает первый элемент;</p>
            <p>findAny() возвращает любой подходящий элемент;</p>
            <p>collect() представление результатов в виде коллекций и других структур данных;</p>
            <p>count() возвращает количество элементов;</p>
            <p>anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;</p>
            <p>noneMatch() возвращает true, если условие не выполняется ни для одного элемента;</p>
            <p>allMatch() возвращает true, если условие выполняется для всех элементов;</p>
            <p>min() возвращает минимальный элемент, используя в качестве условия Comparator;</p>
            <p>max() возвращает максимальный элемент, используя в качестве условия Comparator;</p>
            <p>forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);</p>
            <p>forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;</p>
            <p>toArray() возвращает массив значений;</p>
            <p>reduce()позволяет выполнять агрегатные функции и возвращать один результат.</p>
            <p>sum() возвращает сумму всех чисел;</p>
            <p>average() возвращает среднее арифметическое всех чисел.</p>
          </div>
        </div>

        <div class="nested-block"> конечные методы
          <div class="nested-content">
            <p>filter() отфильтровывает записи, возвращая только записи, соответствующие условию;</p>
            <p>skip() позволяет пропустить определённое количество элементов в начале;</p>
            <p>distinct() возвращает стрим без дубликатов (для метода equals());</p>
            <p>map() преобразует каждый элемент;</p>
            <p>peek() возвращает тот же стрим, применяя к каждому элементу функцию;</p>
            <p>limit() позволяет ограничить выборку определенным количеством первых элементов;</p>
            <p>sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Многопоточность

      <div class="content">

        <div class="nested-block">Каким образом можно создать поток?
          <div class="nested-content">
            <p>1. Создать потомка класса Thread и переопределить его метод run();</p>
            <p> Затем создается экземпляр этого класса и запускается метод start(), который инициирует выполнение
              потока.</p>
            <p>2 public class MyRunnable implements Runnable {</p>
            <p>public void run() {}</p>
            <p> public static void main(String[] args) {</p>
            <p>MyRunnable myRunnable = new MyRunnable();</p>
            <p>Thread thread = new Thread(myRunnable);</p>
            <p> thread.start();</p>
          </div>
        </div>

        <div class="nested-block">Что такое «монитор» мьютекс (mutex)?
          <div class="nested-content">
            <p>это средство обеспечения контроля за доступом к ресурсу.
              У монитора может быть максимум один владелец в каждый текущий момент времени.
              Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа,
              то другой, желающий использовать тот же ресурс,
              должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.</p>
          </div>
        </div>

        <div class="nested-block">Состояния потока
          <div class="nested-content">
            <p>Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван
              метод start().</p>
            <p>Работоспособный (Runnable). когда вызывается метод start(). </p>
            <p>Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий,
              когда Планировщик потоков выбирает его как работающий в данный момент.</p>
            <p>Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по
              нескольким причинам:</p>
            <ul>Ожидание (Waiting).ия, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из
              состояния Ожидания в состояние Работоспособный.</ul>
            <ul>Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в
              миллисекундах.</ul>
            <ul>Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или
              из-за блокировки другого объекта. </ul>
            <ul>Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен.</ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Stream

      <div class="content">

        <div class="nested-block">collect()
          <div class="nested-content">
            <pre><code> &lt;R, A> R collect(Collector&lt;? super T, A, R> collector)</code></pre>
            <p>принимает объект класса Collector, который определяет, как собрать элементы потока в конечный результат.</p>
            <pre><code> &lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)</code></pre>
            <ul>supplier: Это функция-поставщик, создает начальное состояние аккумулятора.
              Аккумулятор - это место, куда мы будем добавлять элементы потока по мере их обработки. 
              Например, ArrayList::new для создания списка.</ul>
            <ul>accumulator: Это функция-аккумулятор, которая принимает текущее состояние аккумулятора и следующий элемент из потока.
                Эта функция обновляет аккумулятор, добавляя элемент в него. Например, List::add для списка.</ul>
            <ul>combiner: Эта функция-комбинатор используется только в параллельных потоках. 
              Она объединяет результаты работы нескольких аккумуляторов в один. 
              Например, если вы обрабатываете поток параллельно и имеете несколько аккумуляторов, combiner объединяет их результаты.</ul>
          </div>
        </div>

        <div class="nested-block">Collector
          <div class="nested-content">
              <p>Простые агрегации</p>
            <ul>toCollection(HashSet::new) </ul>
            <ul>toList(), toSet(), toMap(keyMapper, valueMapper)</ul>
            <ul>counting()</ul>
              <pre><code>
                .collect(Collectors.groupingBy(
                Exam.ExamResult::getGrade,
                Collectors.counting()
                ));</code></pre>
            <ul>summingInt(mapper), summingLong(mapper), summingDouble(mapper), averagingInt(mapper), averagingLong(mapper), averagingDouble(mapper)</ul>  
            <ul>maxBy(comparator), minBy(comparator)</ul>  
            <ul>reducing(identity, mapper, binaryOperator), reducing(binaryOperator), reducing(identity, binaryOperator)</ul>  
            <ul>collectingAndThen(downstream, finisher)</ul>  
              <p>Множественная агрегация: mapping(mapper, downstream</p>
            <p>Группировка groupingBy</p> 
            <p>Разделение partitioningBy</p> 
            <p> Соединение - joining(delimiter)</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>


      </div>
    </div>

    <div class="block">Reflection

      <div class="content">

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>


      </div>
    </div>

  </div>

  <div id="block-2" class="block content">

    <div class="block">Модели разработки, требования, документация
      <div class="content">

        <div class="nested-block">Модели разработки ПО
          <div class="nested-content">
            <p>Модель разработки ПО (Software Development Model, SDM) — структура,
              систематизирующая различные виды проектной деятельности, их взаимодействие и последовательность в процессе
              разработки ПО. </p>

            <p>Водопадная модель:</p>
            <p>(подготовка)</p>
            <ul>Общее планирование -> Пользовательские требования -> системные требования -> тех архитектура -> дизайн
            </ul>
            <p>(Разработка и тестирование)</p>
            <ul>Разработка и отладка</ul>
            <ul>Интеграция и модульные (юнит) тестирование</ul>
            <ul>Инсталляционное тестирование</ul>
            <ul>Системное тесторование</ul>
            <ul>Приемочное тестирование</ul>
            <ul>Итоговое тестирование</ul>

            <p>V-образная модель:</p>
            <p>при использовании v-образной модели
              на каждой стадии «на спуске» нужно думать о том, что и как будет происходить на
              соответствующей стадии «на подъёме». Тестирование здесь появляется уже на самых ранних стадиях развития
              проекта, что позволяет минимизировать риски, а
              также обнаружить и устранить множество потенциальных проблем до того, как они
              станут проблемами реальными.</p>
            <ul>Спуск:
              >Общее планирование -> Пользовательские требования -> системные требования -> тех архитектура -> дизайн
            </ul>
            <ul>Разработка и отладка -> Интеграция и модульные (юнит) тестирование -> Инсталляционное тестирование ->
              Системное тесторование -> Приемочное тестирование -> Итоговое тестирование
            </ul>

            <p>Итерационная инкрементальная модель</p>
            <p> точки зрения жизненного цикла модель является итерационной, т.к. подразумевает многократное повторение
              одних и тех же стадий;</p>
            <p>На входе общее планирование</p>
            <ul>планирование + требования</ul>
            <ul>архитектура и дизайн</ul>
            <ul>разработка и отладка</ul>
            <ul>интеграция и модульные тесты</ul>
            <ul>Установка билда</ul>
            <ul>Тестирование</ul>
            <ul>Оценка результатов</ul>
            <ul>Отчетность</ul>
            <p>Итоговая отчетность</p>


            <p>Спиральная модель (spiral model30) представляет собой частный случай
              итерационной инкрементальной модели, в котором особое внимание уделяется
              управлению рисками, в особенности влияющими на организацию процесса разработки проекта и контрольные
              точки.</p>

            <p>Гибкая модель (agile model35) представляет собой совокупность различных
              подходов к разработке ПО и базируется на т.н. «agile-манифесте»36:
            </p>
            <ul>Люди и взаимодействие важнее процессов и инструменто</ul>
            <ul>Работающий продукт важнее исчерпывающей документации</ul>
            <ul>Сотрудничество с заказчиком важнее согласования условий контракта.</ul>
            <ul>Готовность к изменениям важнее следования первоначальному плану</ul>
            <ul></ul>

            <p>scrum </p>
            <p>Роли</p>
            <ul>Product owner: управляет бэклогом, принимает работу, определяет дату релиза</ul>
            <ul>scrum master: ответственный за выполнение скрап процессов помогает овнеру</ul>
            <ul>Dev + BA + testers</ul>
            <p>События спринта:</p>
            <p>Planning</p>
            <ul>Owner определяет бизнес-задачи спринта, отбирает таски из Бэклога</ul>
            <ul>Developers определяют количесво тасок</ul>
            <ul>Developers оценивает в стори поинтах</ul>
            <ul>Решается кто и какие задачи будет выполнять</ul>
            <ul>В результате создается бэклог спринта</ul>
            <p>Daily</p>
            <ul>Что сделал вчера, что делаю сегодня, какие есть блокеры</ul>
            <p>sprint review</p>
            <ul>Фокус на результат спринта а не процесс</ul>
            <ul>Rjvfylf ghtlcnfdkztn xnj ,skj cltkfyj</ul>
            <p>Demo</p>
            <ul>Может быть частью sprint review</ul>
            <p>Sprint review</p>
            <ul>Что было сделано хорошо, что можно улучшить</ul>

            <p>Kanban</p>
            <ul>Опирается на визуализацию (на доске, на стене)</ul>
            <ul>Ограничение работ выполняемых одновременно</ul>

            <p>Отличия scrum от kanban</p>
            <ul>Принципы и методология:

              Scrum: Scrum основан на итеративном и инкрементальном подходе к разработке. Работа организована в сроки,
              называемые спринтами (обычно от 1 до 4 недель). Каждый спринт начинается с планирования и заканчивается
              обзором и ретроспективой.
              Kanban: Kanban основан на принципе непрерывного потока работы. Задачи представлены в виде карточек на
              доске, где каждая карточка представляет определенную работу. Отличительной чертой Kanban является
              отсутствие фиксированных временных рамок (спринтов).</ul>
            <ul>Итерации и планирование:

              Scrum: В Scrum работа организована в спринтах, и каждый спринт имеет фиксированную продолжительность.
              Планирование происходит на каждом спринте, и изменения обычно вносятся только между спринтами.
              Kanban: В Kanban нет спринтов и фиксированных итераций. Задачи обрабатываются непрерывно, и новые задачи
              могут быть добавлены в доску в любое время.</ul>
            <ul>Команды и роли:

              Scrum: Scrum имеет определенные роли, такие как Scrum Master, Product Owner и разработчики. Scrum Master
              отвечает за процесс, Product Owner за управление требованиями, а разработчики за создание продукта.
              Kanban: В Kanban роли часто более гибкие и не так формализованы. Обычно нет Scrum Master или Product
              Owner. Каждый член команды может участвовать в управлении процессом.</ul>
            <ul>Отслеживание прогресса:

              Scrum: Прогресс отслеживается через бурндаун-чарт, который показывает, сколько работы осталось в спринте.
              Kanban: Прогресс отслеживается через циклы обработки задач и поток работы на доске.</ul>
            <ul>Планирование и приоритизация:

              Scrum: Приоритеты задач определяются на начало спринта. Задачи планируются до начала спринта и защищаются
              от изменений на протяжении спринта.
              Kanban: Приоритеты задач могут меняться в любое время. Задачи могут быть добавлены или удалены, и
              приоритеты могут быть переопределены по мере необходимости.</ul>
            <ul>Внесение изменений:

              Scrum: Внесение изменений в требования на протяжении спринта не рекомендуется, чтобы не нарушать его
              стабильность.
              Kanban: Внесение изменений происходит непрерывно, и новые задачи могут быть добавлены или изменены в любое
              время.</ul>
          </div>
        </div>

        <div class="nested-block">Жизненный цикл тестирования
          <div class="nested-content">
            <ul>Общее планирование и анализ требований</ul>
            <ul>Уточнение критериев приемки</ul>
            <ul>Уточнение стратегии тестирования</ul>
            <ul>Разработка тест кейсов</ul>
            <ul>Выполнение тест кейсов</ul>
            <ul>Фиксация найденных деффектов</ul>
            <ul>Анализ результатов тестирования</ul>
            <ul>Отчетность</ul>
          </div>
        </div>

        <div class="nested-block">требование
          <div class="nested-content">
            <p>Требование (requirement49) — описание того, какие функции и с соблюдением каких условий должно выполнять
              приложение в процессе решения
              полезной для пользователя задачи</p>
            <ul>Позволяют понять, что и с соблюдением каких условий система должна делать.</ul>
            <ul>Предоставляют возможность оценить масштаб изменений и управлять изменениями</ul>
            <ul>Являются основой для формирования плана проекта (в том числе плана тестировани</ul>
            <ul>Помогают предотвращать или разрешать конфликтные ситуации</ul>
            <ul>Упрощают расстановку приоритетов в наборе задач</ul>
            <ul>Позволяют объективно оценить степень прогресса в разработке проекта.</ul>
          </div>
        </div>

        <div class="nested-block">Документация (Проектная / продуктная)
          <div class="nested-content">
            <p>Продуктная документация (product documentation, development documention52) используется проектной
              командой во время разработки и поддержки
              продукта. Она включает</p>
            <ul>План проекта (project management plan53) и в том числе тестовый план
              (test plan54).</ul>
            <ul>Требования к программному продукту (product requirements document,
              PRD55) и функциональные спецификации</ul>
            <ul>Архитектуру и дизайн</ul>
            <ul>Тест-кейсы и наборы тест-кейсов</ul>
            <ul>Технические спецификации (technical specifications62), такие как схемы
              баз данных, описания алгоритмов, интерфейсов и т.д</ul>
            <p>Проектная документация включает продуктную и: </p>
            <ul>Пользовательскую и сопроводительную документацию (user and accompanying documentation64), такую как
              встроенная помощь, руководство по установке и использованию, лицензионные соглаше</ul>
            <ul>Маркетинговую документацию (market requirements document, MRD65),
              которую представители разработчика или заказчика используют как на
              начальных этапах (для уточнения сути и концепции проекта), так и на
              финальных этапах развития проекта (для продвижения продукта на
              рынке).
            </ul>
          </div>
        </div>

        <div class="nested-block"> Уровни и типы требований
          <div class="nested-content">
            <ul>Бизнес-требования (business requirements69) выражают цель, ради которой
              разрабатывается продук</ul>
            <ul>Пользовательские требования (user requirements71) описывают задачи, которые пользователь может выполнять
            </ul>
            <ul>Функциональные требования (functional requirements78) описывают поведение системы, т.е. её действия
              (вычисления, преобразования, проверки, обработку
              и т.д.) </ul>
            <ul>Нефункциональные требования (non-functional requirements79) описывают
              свойства системы (удобство использования, безопасность, надёжность, расширяемость и т.д.), к</ul>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
            <p></p>
            <p></p>
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Виды тестирования, техники тест дизайна
      <div class="content">

        <div class="nested-block">Testing, QC, QA
          <div class="nested-content">
            <ul>Тестирование - соответвие ПО требованиям</ul>
            <ul></ul>
            <ul>quality assurance - охватывает весь цикл
              разработки ПО и затрагивает процессы планирования, проектирования, создания и выполнения
              тест-кейсов</ul>
          </div>
        </div>

        <div class="nested-block">классификация тестирования
          <div class="nested-content">

            <p>По доступу к коду и архитектуре приложения:</p>
            <ul>Метод белого ящика — доступ к коду есть.</ul>
            <ul>Метод чёрного ящика — доступа к коду нет</ul>
            <ul> Метод серого ящика — к части кода доступ есть, к части — нет</ul>

            <p>По уровню детализации приложения (по уровню тестирования):</p>
            <ul>Модульное (юнит) тестирование — проверяются отдельные
              небольшие части приложения.</ul>
            <ul> Интеграционное тестирование — проверяется взаимодействие между
              несколькими частями приложения.</ul>
            <ul>Системное тестирование — приложение проверяется как единое целое.</ul>

            <p>По степени важности тестируемых функций (по убыванию):</p>
            <ul>Smoke - проверка самой важной, самой ключевой
              функциональности</ul>
            <ul>проверка функциональности, используемой типичными пользователями в типичной повседневной деятельности
            </ul>
            <ul>Расширенное тестирование — проверка всей (остальной) функциональности, заявленной в требовани</ul>

            <p>По принципам работы с приложением</p>
            <ul>Позитивное тестирование — все действия с приложением выполняются строго по инструкции без никаких
              недопустимых действий, некорректных данных и т.д</ul>
            <ul>Негативное тестирование — в работе с приложением выполняются
              (некорректные) операции и используются данные, потенциально приводящие к ошибкам (классика жанра — деление
              на ноль)</ul>

            <p>По уровню выполнения (Execution Level):</p>
            <ul>Unit тесты: Тестирование отдельных компонентов или модулей программы</ul>
            <ul>Integration тесты: Тестирование взаимодействия между различными компонентами </ul>
            <ul>System тесты: Проверка всей системы или приложения в целом для подтверждения соответствия требованиям и
              спецификациям.</ul>


            <p>По характеру работы (Testing Nature):</p>
            <ul>Функциональные тесты: Проверка функциональности системы, чтобы убедиться, что она выполняет ожидаемые
              задачи и дает правильные результаты.</ul>
            <ul>Нефункциональные тесты: Тестирование аспектов, не связанных с функциональностью, таких как
              производительность, надежность, безопасность и т.д.</ul>

            <p>По покрытию:</p>
            <p>По глубине</p>
            <ul>Smoke - основная функциональность на валидных </ul>
            <ul>MAT - minimum acceptance test (проверка каждой функции системы на валидных данных)</ul>
            <ul>AT - acceptance test (+негативные) </ul>
            <p>По ширине</p>
            <ul>NFT - new feature test</ul>
            <ul>DV deffect validation (проверка фичи после исправления деввекта)</ul>
            <ul>Regression</ul>

          </div>
        </div>

        <div class="nested-block">Техники тест дизайна
          <div class="nested-content">
            <p>1 Boundary Value Analysis (BVA):</p>
            <p> Тестирование граничных значений включает проверку минимальных и максимальных значений, а также значений,
              которые находятся на границе между допустимыми классами.
              Таким образом, если параметр имеет диапазон от 1 до 100, то для BVA следует проверить значения 1, 2, 99 и
              100.</p>

            <p>2 Equivalence Partitioning (EP):</p>
            <p>предполагает разделение входных данных на классы эквивалентности, где каждый класс должен быть обработан
              одинаково системой.</p>
            <p>Если тестовый случай из одного класса проходит успешно, то ожидается, что все тестовые случаи из этого
              класса также пройдут успешно. Это позволяет уменьшить количество тестовых случаев при сохранении покрытия.
            </p>
            <p>поле для ввода - 2 класса - валидные и невалидные</p>

            <p>3 Pairwise Testing (Combinatorial Testing):</p>
            <p> используется для минимизации количества тестовых случаев, при этом покрывая все возможные комбинации
              параметров. Техника использует комбинации только двух параметров за раз, так как большинство дефектов
              обнаруживаются при взаимодействии двух параметров.
              например оплатапремиум и обычного акка, visa и mastercart </p>

            <p>4 Decision Table Testing (Cause-Effect Graphing):</p>
            <p>Таблицы причин и следствий создаются для представления всех возможных вариантов входных данных и
              соответствующих ожидаемых результатов</p>
            <p></p>

            <p>State Transition Testing:</p>
            <p>Тестовые случаи создаются для проверки переходов между состояниями и корректности реакции системы на
              события.</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">TestRail, Тест-кейс и его жизненный цикл
      <div class="content">

        <div class="nested-block">Тест, тест кейс
          <div class="nested-content">
            <p>Тест (test285) — набор из одного или нескольких тест-кейсов.</p>
            <p>Тест-кейс (test case286) — набор входных данных, условий выполнения и
              ожидаемых результатов, разработанный с целью проверки того или иного
              свойства или поведения программного средства.</p>
            <p>Спецификация тест-кейса (test case specification289) — документ, описывающий набор тест-кейсов
              (включая их цели, входные данные, условия и шаги выполнения, ожидаемые результаты) для тестируемого
              элемента</p>
          </div>
        </div>

        <div class="nested-block">Атрибуты (поля) тест-кейс TestRail
          <div class="nested-content">
            <p>Title</p>
            <p>Идентификатор</p>
            <p>Type (тип): , functionality, performance, regression , usability...</p>
            <p>Приоритет</p>
            <p>Estimate (оценка) содержит оценку времени, которое необходимо затратить
              на выполнение тест-кейса.</p>
            <p>References (ссылки) позволяет хранить ссылки на такие артефакты, как требования, пользовательские
              истории, отчёты о дефектах и иные документы
              (требует дополнительной настройки).</p>
            <p>Preconditions (приготовления) </p>
            <p>Step Description (описание шага) позволяет добавлять описание отдельного
              шага тест-кейса. </p>
            <p>Expected Results (ожидаемые результаты) позволяет описать ожидаемый результат по каждому шагу
            </p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Jira, дефект, аттрибуты, жц, отчет
      <div class="content">

        <div class="nested-block">Дефект, Ожидаемый результат, Фактический результат
          <div class="nested-content">
            <p>Дефект — расхождение ожидаемого и фактического результата.</p>
            <p> Ожидаемый результат — поведение системы, описанное в требованиях.</p>
            <p>Фактический результат — поведение системы, наблюдаемое в процессе
              тестирования.</p>
          </div>
        </div>

        <div class="nested-block">атрибуты (поля) деффекта
          <div class="nested-content">
            <ul>priority - влияние деффекта на бизнес</ul>
            <ul>assignee</ul>
            <ul>reporter</ul>
            <ul>status:
              <ul>open</ul>
              <ul>in progress</ul>
              <ul>resolved</ul>
              <ul> closed</ul>
              <ul>postponed (отложен)<< /ul>
              </ul>
              <ul>resolution (разраб ставит):
                <ul>fixed</ul>
                <ul>fixed inderectly</ul>
                <ul>won't fix</ul>
                <ul>duplicate</ul>
                <ul>incomplete</ul>
                <ul>can not</ul>
              </ul>
              <ul>fix version</ul>

          </div>
        </div>

        <div class="nested-block">Отчёт о дефекте и его жизненный цикл
          <div class="nested-content">
            <p>Отчёт о дефекте (defect report317) — документ, описывающий и приоритизирующий обнаруженный дефект, а
              также содействующий его устранению.</p>
            <ul>Обнаружен (submitted)
              <ul>Назначен (assigned)</ul>
              <ul>Исправлен (fixed) </ul>
              <ul>Проверен (verified)</ul>
              <ul>Закрыт (closed)</ul>
          </div>
        </div>

        <div class="nested-block">Из чего состоит отчет о деффекте
          <div class="nested-content">
            <ul>project</ul>
            <ul>issue type (bug, deffect)</ul>
            <ul>summary (краткое описание): где? что? когда?</ul>
            <ul>severity (критичность): crit, major, minor</ul>
            <ul>affect version</ul>
            <ul>enviroment</ul>
            <ul>description</ul>
            <ul>attachment</ul>
            <ul>expected result</ul>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
            <ul></ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Тест-план и отчёт о результатах тестирования
      <div class="content">

        <div class="nested-block">Тест план
          <div class="nested-content">
            <p>Тест-план (test plan329) — документ, описывающий и регламентирующий
              перечень работ по тестированию, а также соответствующие техники и подходы, стратегию, области
              ответственности, ресурсы, расписание и ключевые даты.</p>
            <ul>Цель (purpose)</ul>
            <ul>Области, подвергаемые тестированию</ul>
            <ul>Области, не подвергаемые тестированию</ul>
            <ul>Тестовая стратегия (test strategy330) и подходы (test approach331). Описание
              процесса тестирования с точки зрения применяемых методов, подходов, видов тестирования, технологий,
              инструментальных средств и т.д.</ul>

            <ul>Критерии:
              <ul>Приёмочные критерии, критерии качества (acceptance criteria332) —
                любые объективные показатели качества, которым разрабатываемый
                продукт должен соответствовать с точки зрения заказчика или пользователя, чтобы считаться готовым к
                эксплуатац</ul>
              <ul>Критерии начала тестирования (entry criteria333) — перечень условий,
                при выполнении которых команда приступает к тестированию. Наличие этого критерия страхует команду от
                бессмысленной траты усилий
                в условиях, когда тестирование не принесёт ожидаемой пользы</ul>
              <ul>Критерии приостановки тестирования (suspension criteria334) — перечень условий, при выполнении которых
                тестирование приостанавливается. Наличие эт</ul>
              <ul>Критерии возобновления тестирования</ul>
              <ul> Критерии завершения тестирования</ul>
            </ul>

            <ul>Ресурсы (resources): программы, человеческие ресурсы, временные, финансовые</ul>
            <ul>Расписание</ul>
            <ul>Роли и ответственность</ul>
            <ul>Оценка рисков</ul>
            <ul>Документация</ul>
            <ul>Метрики (metrics338). Числовые характеристики показателей качества, способы их оценки, формулы и т.д.
            </ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">mock, stub, этапы тестирования, валидация \ верификация

      <div class="content">

        <div class="nested-block">виды тестовых объектов?
          <div class="nested-content">
            <p>пустышка (dummy) - объект, который обычно передается в тестируемый класс в качестве параметра,
              но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.</p>
            <p>фальшивка (fake object) применяется в основном для ускорения запуска ресурсоёмких тестов и является
              заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.</p>
            <p>заглушка (test stub) используется для получения данных из внешней зависимости, подменяя её.
              При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее
              определённый результат.</p>
            <p>шпион (test spy) - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из
              тестируемой системы,
              чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание
              параметров вызовов.</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Чем stub отличается от mock?
          <div class="nested-content">
            <p>stub используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на
              вызовы.</p>
            <p>mock использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и
              контролирует его.</p>
          </div>
        </div>

        <div class="nested-block">основные этапы тестирования ПО
          <div class="nested-content">
            <p>Работа с требованиями. Обсуждение с заказчиком требований к продукту для выявления противоречий и
              потенциальных проблем в работе программ</p>
            <p>Разработка стратегии тестирования и планирование процедур контроля качества. Руководитель команды
              составляет план тестирования: какие виды и инструменты будут применяться в проекте, в какие сроки оно
              должно быть выполнено, с чего оно начнётся и чем закончится</p>
            <p>Создание тестовой документации. На основе стратегии тестирования составляют документы: тест-план,
              тест-кейсы и чек-листы. Задача этого этапа — детально описать, что и как нужно тестировать.</p>
            <p>Основное тестирование. Ключевой этап всего процесса — программу тестируют по заранее написанным сценариям
              и выявляют ошибки, на основе которых составляют подробные отчёты.</p>
            <p>Стабилизация. Разработчики устраняют найденные ошибки, после чего проводится повторное или
              регресс-тестирование — оно помогает понять, как программа ведёт себя с учётом изменений.</p>
            <p>Эксплуатация и поддержка. Так как часто ошибки обнаруживаются уже после релиза, тестировщики продолжают
              работать с программой и на этом этапе — например, чтобы собрать обратную связь от пользователей.</p>
          </div>
        </div>

        <div class="nested-block">Чем валидация отличается от верификации?
          <div class="nested-content">
            <p>Верификация — это проверка системы на соответствие условиям, которые были определены в начале разработки.
            </p>
            <p>Валидация — это оценка соответствия работы программы ожиданиям пользователя.</p>
          </div>
        </div>

        <div class="nested-block">Что такое тест-план и зачем он нужен?
          <div class="nested-content">
            <p>Тест-план — это документ, который поэтапно описывает весь процесс тестирования, начиная от целей и сроков
              и заканчивая обязанностями каждого члена команды.</p>
          </div>
        </div>

        <div class="nested-block">Чем тест-кейс отличается от чек-листа?
          <div class="nested-content">
            <p>Чек-лист — это список того, что нужно проверить. Например, можно составить чек-лист для проверки сайта
              или отдельного его компонента — скажем, личного кабинета или корзины.</p>
            <p>Тест-кейс — это пошаговое описание того, как мы будем тестировать ту или функцию.</p>
          </div>
        </div>


      </div>
    </div>

  </div>

  <div id="block-3" class="block content">
    <div class="block">Шаблоны для тестирования
      <div class="content">

        <div class="nested-block">Page Object паттерн
          <div class="nested-content">
            <p>позволяет организовать и структурировать код автотестов.
              абстрагировать каждую страницу веб-приложения в отдельный класс, который предоставляет методы для
              взаимодействия
              с элементами на этой странице.
              Это помогает разделить логику тестов от логики работы с пользовательским интерфейсом, упрощая тестирование
              и поддержку </p>
            <p>Класс страницы (Page Class):</p>
            <ul>Каждая страница веб-приложения представляется в виде отдельного класса.</ul>
            <ul>Класс содержит локаторы элементов (XPath, CSS, ID и т.д.), которые идентифицируют элементы на странице.
            </ul>
            <ul>Класс также содержит методы для взаимодействия с элементами, такие как клики, ввод текста, получение
              текста и т.д.</ul>
            <p>(Step Class)</p>
            <ul>Как правило, в тестовом классе выполняются только вызовы методов из Steps классов, которые, в свою
              очередь, взаимодействуют с Page Object классами.</ul>
            <p>Тестовый класс (Test Class)</p>
          </div>
        </div>

        <div class="nested-block">Test-driven development (TDD)
          <div class="nested-content">
            <p>Способ разработки ПО, когда тест кейсы разрабатываются и зачастую автоматизируются до разработки самого
              ПО</p>
          </div>
        </div>

        <div class="nested-block">Data-Driven Testing (DDT)
          <div class="nested-content">
            <p> это паттерн тестирования, который позволяет проводить тесты с использованием различных наборов данных.
              Вместо того чтобы зашивать данные напрямую в тестовый код, в DDT данные разделяются от логики теста.</p>
            <p>Основные компоненты</p>
            <ul>Тестовый сценарий: Это код теста, который выполняет определенные проверки или действия на основе данных
            </ul>
            <ul>Входные данные (Data Sets): Наборы данных, которые используются для запуска тестов с различными
              значениями.
              Эти данные могут быть представлены в виде таблицы, файла Excel, базы данных и т.д.</ul>
          </div>
        </div>

        <div class="nested-block">Behavior-Driven Development (BDD)
          <div class="nested-content">
            <p>это методология разработки программного обеспечения, которая ставит в центр внимания поведение
              (поведенческие аспекты) системы и позволяет лучше связать бизнес-аналитиков, разработчиков и тестировщиков
              в процессе разработки.</p>
            <p>Основные принципы BDD</p>
            <ul>Язык описания поведения: BDD способствует использованию общего и понятного языка описания поведения
              системы, который доступен и понятен всем участникам разработки</ul>
            <ul>Сценарии поведения: В BDD системное поведение описывается с помощью сценариев, представленных в виде
              "Шагов" (Steps) с языковым выражением Gherkin (Given-When-Then). Это позволяет легко понять, что ожидается
              от системы в определенных ситуациях.</ul>
            <ul>Общая понятность и Тесное взаимодействие между командами: Основной идеей BDD является создание общего
              понимания между всеми участниками разработки,</ul>

            <p>Ключевые элементы BDD:</p>
            <ul>Шаги (Steps): Шаги представляют собой действия или состояния системы в языке Gherkin: Given (Учитывая),
              When (Когда) и Then (Тогда). Они представляют сценарии поведения системы.</ul>
            <ul>Фича (Feature): Фича представляет собой файл сценария на языке Gherkin, описывающий функциональность или
              особенность системы.</ul>
            <ul>Сценарий (Scenario): Сценарий представляет собой конкретный тестовый сценарий, описанный с
              использованием Шагов. Каждый сценарий обычно содержит предусловия (Given), действия (When) и ожидаемые
              результаты (Then)</ul>
          </div>
        </div>

        <div class="nested-block">Keyword-Driven Testing (KDT)
          <div class="nested-content">
            <p>это методология, разделяет тестовые сценарии и наборы действий (ключевые слова).
              В KDT тесты представлены в виде наборов ключевых слов и аргументов, которые обозначают действия и
              проверки,
              выполняемые в процессе тестирования. </p>
            <ul>Предположим, у нас есть тестирование функции сложения двух чисел. Мы можем определить следующие ключевые
              слова:</ul>
            <ul>Open Browser: Открывает браузер.</ul>
            <ul>Navigate To: Переходит на указанный URL.</ul>
            <ul>Enter Number: Вводит число в указанное поле.</ul>
            <ul>Click Add Button: Нажимает кнопку "Сложить".</ul>
            <ul>Verify Result: Проверяет результат сложения на странице.</ul>
          </div>
        </div>

        <div class="nested-block">Singleton
          <div class="nested-content">
            <p>паттерн проектирования, который гарантирует, что у класса есть только один единственный экземпляр, и
              предоставляет глобальную точку доступа к этому экземпляру.</p>
            <ul>Приватный конструктор:</ul>
            <ul>Статическое поле экземпляра: Класс Singleton содержит статическое поле, которое хранит единственный
              экземпляр объекта</ul>
            <ul>Статический метод для доступа: Класс Singleton предоставляет статический метод, который возвращает
              единственный экземпляр класса. Этот метод обычно называется getInstance().</ul>
            <ul>Ленивая инициализация: Объект Singleton создается только при первом вызове метода getInstance()</ul>
          </div>
        </div>

        <div class="nested-block">Factory Method (Фабричный метод)
          <div class="nested-content">
            <p>Он предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип
              создаваемых объектов. </p>
            <p>Пример: у нас есть две роли - администратор и обычный пользователь.</p>
            <p>interface AuthenticationStrategy {</p>
            <p>void login(String username, String password);}</p>


            <p>class AdminAuthenticationStrategy implements AuthenticationStrategy {</p>
            <p>public void login(String username, String password) {...}</p>

            <p>class UserAuthenticationStrategy implements AuthenticationStrategy {</p>
            <p>public void login(String username, String password) {...}</p>

            <p>abstract class AuthenticationStrategyFactory {</p>
            <p>public abstract AuthenticationStrategy createAuthenticationStrategy();}</p>

            <p>class AdminAuthenticationStrategyFactory extends AuthenticationStrategyFactory {</p>
            <p>public AuthenticationStrategy createAuthenticationStrategy() {</p>
            <p> return new AdminAuthenticationStrategy();}}</p>

            <p>class UserAuthenticationStrategyFactory extends AuthenticationStrategyFactory {</p>
            <p>public AuthenticationStrategy createAuthenticationStrategy() {</p>
            <p> return new UserAuthenticationStrategy();;}}</p>

            <p>AuthenticationStrategyFactory adminFactory = new AdminAuthenticationStrategyFactory();</p>
            <p>AuthenticationStrategyFactory userFactory = new UserAuthenticationStrategyFactory();</p>

            <p>AuthenticationStrategy adminStrategy = adminFactory.createAuthenticationStrategy();</p>
            <p>AuthenticationStrategy userStrategy = userFactory.createAuthenticationStrategy();</p>

            <p>// Сценарий тестирования авторизации администратора</p>
            <p>adminStrategy.login("admin", "adminPassword");</p>

            <p>// Сценарий тестирования авторизации обычного пользователя</p>
            <p>userStrategy.login("user", "userPassword");</p>

          </div>
        </div>

        <div class="nested-block">Factory Method (Фабричный метод)
          <div class="nested-content">
            <p></p>
            <ul></ul>
            <ul></ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Шаблоны, Patterns

      <div class="content">

        <div class="nested-block">Типы шаблонов
          <div class="nested-content">
            <p>Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание
              экземпляра. Они позволяют сделать систему независимой от способа создания, композиции и представления
              объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять созданный объект, а шаблон,
              порождающий объекты, делегирует создание объектов другому объекту.</p>
            <p>Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже
              существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.</p>
            <p>Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом
              его гибкость.</p>
          </div>
        </div>

        <div class="nested-block">Порождающие
          <div class="nested-content">
            <p>Абстрактная фабрика (Abstract factory) - Класс, который представляет собой интерфейс для создания других
              классов.</p>
            <p>Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.</p>
            <p>Фабричный метод (Factory method) - Делегирует создание объектов наследникам родительского класса. Это
              позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами
              на более высоком уровне.</p>
            <p>Прототип (Prototype) - Определяет интерфейс создания объекта через клонирование другого объекта вместо
              создания через конструктор.</p>
            <p>Одиночка (Singleton) - Класс, который может иметь только один экземпляр.</p>
          </div>
        </div>

        <div class="nested-block"> структурные
          <div class="nested-content">
            <p>Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых
              использует, а другой предоставляет несовместимый с первым интерфейс.</p>
            <p>Мост (Bridge) - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса
              независимо.</p>
            <p>Компоновщик (Composite) - Объект, который объединяет в себе объекты, подобные ему самому.</p>
            <p>Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования
              наследования.</p>
            <p>Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
            </p>
          </div>
        </div>

        <div class="nested-block">Поведенческие
          <div class="nested-content">
            <p>Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней
              ответственности.</p>
            <p>Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам
              объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.</p>
            <p>Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что
              при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.</p>
          </div>
        </div>

        <div class="nested-block">SOLID
          <div class="nested-content">
            <p>Single responsibility — принцип единственной ответственности</p>
            <p>обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью
              инкапсулирована в класс</p>
            <p>Open-closed — принцип открытости / закрытости</p>
            <p>программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для
              изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.</p>
            <p>Liskov substitution principle / LSP</p>
            <p>объекты базового класса должны быть заменяемыми объектами производного класса без изменения правильности
              выполнения программы. Если класс B является подтипом класса A, то объекты класса A могут быть заменены
              объектами класса B без изменения корректности программы.</p>
            <p>Принцип разделения интерфейса (interface segregation principle / ISP)</p>
            <p>слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, </p>
            <p>Принцип инверсии зависимостей (dependency inversion principle / DIP</p>
            <p>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</p>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="block-4" class="block content">
    <div class="block">HTML, TCP IP, DHCP, DNS, Websocket
      <div class="content">

        <div class="nested-block">HTML
          <div class="nested-content">
            <p>HTML, HyperText Markup Language («язык гипертекстовой разметки») — стандартизированный язык разметки
              документов в WWW. На данный момент актуальна 5 версия этого языка - HTML5.</p>
          </div>
        </div>

        <div class="nested-block">уровни модели OSI?
          <div class="nested-content">
            <p>Физический (physical) Биты (bit) Работа со средой передачи, сигналами и двоичными данными USB, витая пара
            </p>
            <p>Канальный (data link) Биты (bit) / Кадры (frame) Физическая адресация Ethernet, IEEE 802.2, L2TP</p>
            <p>Сетевой (network) Пакеты (packet) Определение маршрута и логическая адресация IP, AppleTalk</p>
            <p>Транспортный (transport) Сегменты(segment) / Дейтаграммы(datagram) Прямая связь между конечными пунктами
              и надежность TCP, UDP</p>
            <p>Прикладной (application) - Доступ к сетевым службам HTTP, FTP</p>
          </div>
        </div>

        <div class="nested-block">TCP/IP?
          <div class="nested-content">
            <p>TCP — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки
              соединения между двумя хостами. </p>
            <p>IP (Internet Protocol) - маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию,
              фрагментацию и восстановление пакетов. В его задачу входит продвижение пакета между сетями – от одного
              маршрутизатора до другого и тех пор, пока пакет не попадет в сеть назначения.</p>
            <p>HTTP (80 порт/TCP) и HTTPS (443 порт/TCP) – отличие S в надстройке безопасности (+шифрование) </p>
            <p>Почта: SMTP (25 порт/TCP) – отправка на почтовый сервер </p>
            <p>IMAP (143 порт/TCP) – для авторизации и подключения </p>
            <p>Шифрование трафика – SSH (22 порт/TCP) – SSH-ключ – файл для доступа (к серверу) </p>
          </div>
        </div>

        <div class="nested-block">DHCP
          <div class="nested-content">
            <p>– сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры,
              необходимые для работы в сети TCP/IP.</p>
          </div>
        </div>

        <div class="nested-block">DNS (Domain Name System)
          <div class="nested-content">
            <p>компьютерная информационная система для получения информации о доменах. Набор серверов, хранящих
              соответствие IP-адреса и домена. </p>
          </div>
        </div>

        <div class="nested-block">Что такое WebSocket?
          <div class="nested-content">
            <p>WebSocket — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями
              между браузером и web-сервером в режиме реального времени.</p>
          </div>
        </div>

        <div class="nested-block">REST
          <div class="nested-content">
            <p>REST (Representational State Transfer) - это архитектурный стиль для разработки распределенных систем, 
              особенно веб-сервисов.  Он представляет собой набор ограничений и рекомендаций, которые описывают, 
              как должны взаимодействовать клиенты и серверы в распределенных средах. 
              Основной концепцией REST является представление ресурсов (например, объектов, данных) 
              через уникальные URL и использование стандартных методов HTTP (GET, POST, PUT, DELETE) для взаимодействия с ними.
            </p>
            <p>RESTful - это термин, который описывает веб-сервисы или архитектурные решения, следующие принципам и ограничениям REST. Если сервис или система соответствует этим принципам, то её можно назвать RESTful.</p>
            <p>Основные принципы REST включают:</p>
            <ul>Клиент-Сервер: Разделение клиента и сервера, что позволяет им развиваться независимо друг от друга.
            </ul>
            <ul>Без состояния (Stateless): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию, чтобы сервер мог понять и выполнить запрос. Состояние клиента не хранится на сервере между запросами.</ul>
            <ul>Кеширование: Серверы могут помечать ответы как кешируемые или некешируемые. Клиенты могут кэшировать ответы, чтобы избежать повторных запросов к серверу.</ul>
            <ul>Единообразие интерфейса: Интерфейс взаимодействия между клиентом и сервером должен быть единообразным. Это включает использование уникальных URL для доступа к ресурсам и стандартных HTTP-методов.</ul>
            <ul>Слои (Layered System): Архитектура может включать в себя промежуточные серверы (прокси, балансировщики нагрузки), которые обеспечивают дополнительные функции.</ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">API, HTTP, GET, 404, Mocking, SOAP
      <div class="content">

        <div class="nested-block">API, типы
          <div class="nested-content">
            <p>Application Programming Interface) используют его для создания веб-сервисов,
              которые могут обмениваться данными с другими приложениями и сервисами через интернет.
            <p>Типы API</p>
            <ul>
              REST - это набор принципов архитектуры, а RESTful - это API, которое реализует эти Принципы.
              основан на HTTP-протоколе и 
              использует запросы HTTP для обмена данными между клиентом и сервером.
              Для каждого запроса клиент должен указать метод (GET, POST, PUT, DELETE), URL-адрес и параметры запроса.
            </ul>
            <ul>SOAP API (Simple Object Access Protocol API)
              используют его для обмена данными между приложениями, работающими на разных платформах, например, между
              .NET и Java. </ul>
            <ul>GraphQL API  — это относительно новый тип API. используют его для создания гибких и эффективных
              веб-сервисов,
              которые могут быстро и точно получать необходимые данные.
              GraphQL API основан на запросах, которые отправляются клиентом серверу в формате GraphQL.
              Каждый запрос содержит только те данные, которые нужны клиенту, что делает этот тип API более быстрым
              и эффективным, чем другие. </ul>
            <ul>WebSocket API
              WebSocket API — это тип API, который используется для создания постоянного соединения между клиентом
              и сервером.
              Он позволяет клиенту и серверу передавать данные в режиме реального времени,
              без необходимости постоянно отправлять запросы.
              Например, передача видеопотока в видеохостинге или сервисе облачного гейминга. </ul>
          </div>
        </div>

        <div class="nested-block">Структура HTTP запроса
          <div class="nested-content">
            <ul>Стартовая строка (Start Line): Стартовая строка определяет тип запроса,
              URI (Uniform Resource Identifier) и версию HTTP протокола
            например:
            GET /wiki/HTTP HTTP/1.0
            Host: ru.wikipedia.org</ul>
            <ul>Заголовки (Headers): Заголовки содержат дополнительную информацию о запросе,
              такую как тип содержимого (Content-Type), длину контента (Content-Length), аутентификацию и т.д.</ul>
            <ul>Тело (Body): Тело запроса содержит данные, которые могут передаваться на сервер. </ul>
          </div>
        </div>

        <div class="nested-block">Аутентификация / авторизация
          <div class="nested-content">
            <p>Аутентификация - это процесс проверки подлинности пользователя или приложения
              Наиболее распространенные методы аутентификации включают OAuth, JWT (JSON Web Token) и API ключи
            </p>
            <p>JWT - это стандарт для представления информации между двумя сторонами в виде JSON объекта.</p>
            <p>Авторизация (Authorization) определяет, какие действия и ресурсы может выполнять или получать
              аутентифицированный пользователь</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">КОДЫ
          <div class="nested-content">
            <p>1xx (Informational): Информационные, запрос получен и сервер продолжает обработку.</p>
            <p>200 OK: успешное выполнение запроса и возврат данных клиенту.</p>
            <p>201 Created: успешное создание нового ресурса в результате POST запроса.</p>
            <p>204 No Content:успешно , но в ответе нет содержимого, например, при успешном удалении ресурса.</p>

            <p>3xx (Redirection):</p>
            <p>4xx (Client Errors):</p>

            <p>400 Bad Request:некорректный запрос, и сервер не может обработать.</p>
            <p>401 Unauthorized: клиент должен предоставить аутентификацию для получения доступа к запрашиваемому
              ресурсу.</p>
            <p>403 Forbidden: Клиент прошел аутентификацию, но не имеет разрешения для доступа к запрашиваемому ресурсу.
            </p>
            <p>404 Not Found: Запрашиваемый ресурс не найден на сервере.</p>
            <p>405 Method Not Allowed: Клиент использовал метод, который не разрешен для запрашиваемого ресурса.</p>

            <p>5xx (Server Errors):</p>
            <p>500 Internal Server Error: Общий код ошибки, который указывает на ошибку на стороне сервера, когда
              обработка запроса не удалась.</p>
            <p>502 Bad Gateway: Ошибка на стороне промежуточного сервера или шлюза при попытке получить ответ от другого
              сервера.</p>
            <p>503 Service Unavailable: Сервер временно недоступен из-за перегрузки или обслуживания.</p>
            <p>504 Gateway Timeout: Время ожидания истекло для запроса, направленного на промежуточный сервер или шлюз.
            </p>
          </div>
        </div>

        <div class="nested-block"> Swagger/OpenAPI
          <div class="nested-content">
            <p>: Swagger/OpenAPI - это инструменты для создания, документирования и тестирования RESTful API. Они
              предоставляют стандартизированный способ описания структуры и функциональности API.</p>
          </div>
        </div>

        <div class="nested-block">Mocking
          <div class="nested-content">
            <p>Мокирование (Mocking) - это техника в программировании и тестировании, которая заключается в создании
              "поддельных"
              или "заглушечных" объектов, которые эмулируют поведение реальных объектов в контролируемой среде.</p>
            <p>мокирование позволяет изолировать API от внешних сервисов, баз данных или других внешних ресурсов, чтобы
              тестировать его функциональность независимо от этих зависимостей. Вместо реальных запросов к внешним
              ресурсам,
              в тестах используются моки (mocks), которые эмулируют ответы, которые были бы получены от реального
              сервиса.</p>
            <ul>Тестирование без реальных сервисов: Мокирование позволяет проводить тестирование API даже в том случае,
              если реальные сервисы или ресурсы недоступны, не готовы или еще не реализованы.</ul>
            <ul>Контроль над данными и ответами: С использованием мокирования можно точно определить, какие данные и
              какие ответы должны быть получены из моков. </ul>
            <ul>Сокращение времени выполнения тестов: Запросы к реальным сервисам могут занимать время, что может
              замедлить выполнение тестов.</ul>
            <ul>Изоляция от внешних изменений: Используя моки, можно избежать проблем, связанных с изменениями во
              внешних сервисах или ресурсах, которые могут повлиять на результаты тестирования.</ul>
            <ul>Проверка обработки ошибок: Мокирование позволяет создать сценарии, когда внешний сервис возвращает
              ошибку или некорректные данные</ul>
            <ul>Тестирование на ранних этапах разработки: Мокирование позволяет тестировать API даже на ранних этапах
              разработки, когда реальные сервисы еще не готовы или изменяются.</ul>
          </div>
        </div>

        <div class="nested-block">SOAP (Simple Object Access Protocol)
          <div class="nested-content">
            <p>то протокол обмена сообщениями в формате XML удаленными системами, работающими на различных платформах и
              языках программирования</p>
            <p>Структура сообщения SOAP:</p>
            <ul>Envelope («конверт»). Это корневой элемент. Определяет XML-документ как сообщение SOAP с помощью
              пространства имен</ul>
            <ul>Заголовок (Header): Опциональная часть сообщения, которая содержит дополнительные метаданные или
              информацию о безопасности и маршрутизации сообщения.</ul>
            <ul>Тело (Body): Обязательная часть сообщения, которая содержит данные, которые требуется передать между
              отправителем и получателем.</ul>
            <ul>Fault (Ошибка): Опциональная часть сообщения, которая используется для передачи информации об ошибках и
              исключительных ситуациях.</ul>

          </div>
        </div>


        <div class="nested-block">Get Post Put Patch
          <div class="nested-content">
            <p>Get - запрашивает - индепотентный</p>
            <p>HEAD - запрашивает - индепотентный в ответе сервера отсутствует тело. бычно применяется для извлечения метаданных, проверки наличия ресурса</p>
            <p>POst - создает новый ресурс из данных</p>
            <p>Put заменяет - индепотентный 
              Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус 201 (Created). 
              Если же ресурс был изменён, то сервер возвращает 200 (Ok) или 204 (No Content)
            </p>
            <p>Patch - обновляет</p>
            <p>GET передает данные серверу, используя URL, тогда как POST передает данные, используя тело HTTP запроса.
              Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать
              через GET. POST может отправлять гораздо большие объемы данных. Лимит устанавливается web-server и
              составляет обычно около 2 Mb.

              Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль)
              не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. Иногда
              это преимущество превращается в недостаток - вы не сможете послать данные за кого-то другого.</p>
          </div>
        </div>

        <div class="nested-block">A
          <div class="nested-content">
            <p>B</p>
          </div>
        </div>





      </div>
    </div>
  </div> 

  <div id="block-5" class="block content">

    <div class="block">БД, SQL

      <div class="content">

        <div class="nested-block">БД, СУБД, типы
          <div class="nested-content">
            <p>БД (база данных) - это организованная коллекция данных, которая хранится и управляется в
              структурированном формате.</p>
            <p>СУБД (система управления базами данных) - это программное обеспечение, которое обеспечивает управление и
              обработку данных в базе данных. С</p>
            <ul>Реляционные СУБД (RDBMS): Это самый распространенный тип СУБД. Он использует модель реляционных таблиц
              для хранения данных. В реляционных СУБД данные представляются в виде таблиц с рядами и столбцами, а между
              таблицами устанавливаются связи. </г>
              <ul>Документоориентированные СУБД: Этот тип СУБД хранит данные в формате документов, обычно в формате JSON
                или BSON.</ul>
              <ul>Ключ-значение (Key-Value) СУБД: В этом типе СУБД данные хранятся в виде пар ключ-значение. </ul>
              <ul>Колоночные СУБД: Колоночные СУБД хранят данные в виде колонок, вместо строк, как это делается в
                реляционных СУБД. Это позволяет более эффективно хранить данные и улучшает производительность для
                операций чтения. Примеры: Apache Cassandra, HBase.</ul>
              <ul>Временные ряды СУБД: Этот тип СУБД предназначен для работы с данными временных рядов, такими как
                данные датчиков, логи, статистика и т. д. Они оптимизированы для работы с временными метками данных и
                обеспечивают высокую скорость вставки и извлечения данных. Примеры: InfluxDB, TimescaleDB.</ul>
          </div>
        </div>

        <div class="nested-block">операторы SQL?
          <div class="nested-content">
            <p>операторы определения данных (Data Definition Language, DDL):</p>
            <ul>CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),</ul>
            <ul>ALTER изменяет объект,</ul>
            <ul>DROP удаляет объект;</ul>
            <p>операторы манипуляции данными (Data Manipulation Language, DML):</p>
            <ul>SELECT выбирает данные, удовлетворяющие заданным условиям,</ul>
            <ul>INSERT добавляет новые данные,</ul>
            <ul>UPDATE изменяет существующие данные,</ul>
            <ul>DELETE удаляет данные;</ul>
            <p>операторы определения доступа к данным (Data Control Language, DCL):</p>
            <ul>GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,</ul>
            <ul>REVOKE отзывает ранее выданные разрешения,</ul>
            <ul>DENY задает запрет, имеющий приоритет над разрешением;</ul>
          </div>
        </div>

        <div class="nested-block">«представление» (view) и для чего оно применяется?
          <div class="nested-content">
            <p>Представление, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным
              образом.
              В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в
              структуре памяти, напоминающей SQL таблицу. </p>
          </div>
        </div>

        <div class="nested-block">первичный ключ?
          <div class="nested-content">
            <p>RIMARY KEY предназначен для однозначной идентификации каждой записи в таблице и является строго
              уникальным (UNIQUE): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые
              значения (NULL) в PRIMARY KEY не допускаются.
              Если в качестве PRIMARY KEY используется несколько полей, их называют составным ключом.</p>
          </div>
        </div>

        <div class="nested-block">внешний ключ?
          <div class="nested-content">
            <p>FOREIGN KEY также является атрибутом ограничения и обеспечивает связь двух таблиц.
              По сути, это поле или несколько полей, которые ссылаются на PRIMARY KEY в родительской таблице.</p>
          </div>
        </div>

        <div class="nested-block">ограничения (constraints)
          <div class="nested-content">
            <p>UNIQUE — гарантирует уникальность значений в столбце;</p>
            <p>NOT NULL — значение не может быть NULL;</p>
            <p>INDEX — создаёт индексы в таблице для быстрого поиска/запросов;</p>
            <p>CHECK — значения столбца должны соответствовать заданным условиям;</p>
            <p>DEFAULT — предоставляет столбцу значения по умолчанию.</p>
          </div>
        </div>

        <div class="nested-block">синтаксис оператора SELECT
          <div class="nested-content">
            <p>SELECT - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному
              условию. Имеет следующую структуру:</p>
            <p>SELECT [DISTINCT | DISTINCTROW | ALL]</p>
            <p>FROM table_references</p>
            <p>[WHERE where_definition]</p>
            <p>[GROUP BY {unsigned_integer | column | formula}]</p>
            <p>[HAVING where_definition]</p>
            <p> [ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]</p>
          </div>
        </div>

        <div class="nested-block">JOIN
          <div class="nested-content">
            <p>JOIN - оператор языка SQL, Предназначен длявыборки данных из двух таблиц и включения этих данных в один
              результирующий набор.</p>
            <p>SELECT field_name [,... n]</p>
            <p>FROM</p>
            <p>Table1</p>
            <p>{INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN</p>
            <p> Table2</p>
            <p>{ON <condition> | USING (field_name [,... n])}</p>
          </div>
        </div>

        <div class="nested-block">четыре основных типа соединения в SQL JOIN
          <div class="nested-content">
            <p>1 INNER JOIN выбирает только те строки, которые имеют соответствующие значения в обеих таблицах </p>
            <p>SELECT * FROM table1</p>
            <p>INNER JOIN table2</p>
            <p>ON table1.column = table2.column;</p>
            <p> LEFT JOIN возвращает все строки из левой таблицы и только соответствующие строки из правой таблицы. Если
              нет соответствующих значений в правой таблице, будут возвращены NULL-значения.</p>
            <p>SELECT *
              FROM table1</p>
            <p>LEFT JOIN table2</p>
            <p>ON table1.column = table2.column;</p>
            <p>Чтобы выбрать только из левой таблицы добавить</p>
            <p>Where table2.key is NULL </p>
            <p> RIGHT JOIN возвращает все строки из правой таблицы и только соответствующие строки из левой таблицы.
            </p>
            <p>FULL OUTER JOIN — объединяет записи из обеих таблиц (если условие объединения равно true)
              и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений.
              Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
            </p>
          </div>
        </div>

        <div class="nested-block"> основные агрегатные функции.
          <div class="nested-content">
            <p>COUNT - производит подсчет записей, удовлетворяющих условию запроса</p>
            <p>SUM - вычисляет арифметическую сумму всех значений колонки;</p>
            <p>AVG - вычисляет среднее арифметическое всех значений</p>
            <p>MAX - определяет наибольшее из всех выбранных значений; MIN - определяет наименьшее из всех выбранных
              значений.</p>
          </div>
        </div>

        <div class="nested-block">IN, BETWEEN, LIKE?
          <div class="nested-content">
            <p>IN - определяет набор значений.</p>
            <p>SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');</p>
            <p>BETWEEN определяет диапазон значений.</p>
            <p>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;</p>
            <p>LIKE применим только к полям типа CHAR или VARCHAR</p>
            <p>_ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не
              будет соответствовать 'brat'.</p>
            <p>% замещает последовательность любого числа символов. </p>
            <p>SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';</p>
          </div>
        </div>

        <div class="nested-block"> Self JOIN?
          <div class="nested-content">
            <p>Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные
              таблицы.</p>
            <p>Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.</p>
          </div>
        </div>

        <div class="nested-block">оператор UNION?
          <div class="nested-content">
            <p>Он используется для объединения полученных данных из двух или более запросов,
              которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в том же
              порядке.</p>
          </div>
        </div>

        <div class="nested-block">псевдонимы Aliases
          <div class="nested-content">
            <p>SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу.
              Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами.</p>
          </div>
        </div>

        <div class="nested-block">Как найти дубли в поле email?
          <div class="nested-content">
            <p>SELECT email, COUNT(email)</p>
            <p>FROM customers</p>
            <p>GROUP BY email</p>
            <p>HAVING COUNT(email) > 1;</p>
          </div>
        </div>

        <div class="nested-block">Выберите только уникальные имена
          <div class="nested-content">
            <p>SELECT DISTINCT name FROM users;</p>
          </div>
        </div>
      </div>
    </div>

    <div class="block">JDBC

      <div class="content">

        <div class="nested-block">JDBC
          <div class="nested-content">
            <p>JDBC, Java DataBase Connectivity (соединение с базами данных на Java)
              — промышленный стандарт взаимодействия Java-приложений с различными СУБД.
              Реализован в виде пакета java.sql, входящего в состав Java SE.</p>
          </div>
        </div>

        <div class="nested-block"> JDBC URL?
          <div class="nested-content">
            <p> protocol: (протокола) - всегда jdbc:.</p>
            <p>(подпротокола) - это имя драйвера или имя механизма соединения с базой данных.</p>
            <p>подымя - //<hostname>:<port>/<subsubname.< /p>
                    <p>jdbc:mysql://localhost:3306/Test</p>
          </div>
        </div>

        <div class="nested-block">Из каких частей стоит JDBC?
          <div class="nested-content">
            <p>JDBC API, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и
              методы объявлены в двух пакетах - java.sql и javax.sql;</p>
            <p>JDBC-драйвер, компонент, специфичный для каждой базы данных.</p>
          </div>
        </div>

        <div class="nested-block">основные классы и интерфейсы JDBC.
          <div class="nested-content">
            <p>java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем
              получить соединение с базой данных.</p>
            <p>java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями.
            </p>
            <p>java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют
              отправить запрос к источнику данных.</p>
            <p>java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать
              значения отдельных полей в текущей записи.</p>
          </div>
        </div>

        <div class="nested-block">основные этапы работы с базой данных при использовании JDBC.
          <div class="nested-content">
            <p>Регистрация драйверов;</p>
            <p>Установление соединения с базой данных;</p>
            <p>Создание запроса(ов) к базе данных;</p>
            <p>Выполнение запроса(ов) к базе данных;</p>
            <p>Обработка результата(ов);</p>
            <p>Закрытие соединения с базой данных.</p>
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>


  </div>

  <div id="block-6" class="block content">

    <div class="block">Операции

      <div class="content">

        <div class="nested-block">Отмена
          <div class="nested-content">
            <p>untracked, unmodified, modified, staged A - B - C</p>
            <p>reset --soft B есть изменения из коммита C они индексе</p>
            <p>reset --mixed B У нас есть все изменения из С, они не в индексе</p>
            <p>reset --hard B нет изменений из С</p>
            <p>restore --staged FILE Убрать файл из индексации</p>
            <p>restore FILE Отменить изменения в файле</p>
            <p>git revert [commit SHA] создается отменяющий коммит</p>
          </div>
        </div>


        <div class="nested-block">Удаление
          <div class="nested-content">
            <p>rm --cached README Удалить файл из индекса, оставив его при этом в рабочем каталоге</p>
            <p>mv file_from file_to Как переименовать файл</p>
            <p>branch -d mergBR Удалить слитую ветку (merged)</p>
            <p>branch -D noMergBr Удалить не слитую ветку со всеми изменениями</p>
            <p>push origin -d branchForDelete Удалить удаленную ветку</p>
          </div>
        </div>

        <div class="nested-block">Просмотр
          <div class="nested-content">
            <p>git branch -a</p>
            <p>git branch -a показать все ветки</p>
            <p>git branch --merged список вмерженных в в текущую</p>
            <p>git branch --merged master список вмерженных в мастер</p>
            <p>git branch --no-merged посмотреть неслитые ветки (git branch --no-merged)</p>
            <p>git remote show origin посмотреть удаленные ветки в репозитории</p>
            <p>log Просмотр истории</p>
            <p>git log --name-status COMMIT_HASH Как найти список файлов, которые изменились в определенном коммите?</p>
            <p>remote -v Просмотреть адреса репозиториев для чтения и записи</p>
          </div>
        </div>

        <div class="nested-block">Переименование
          <div class="nested-content">
            <p>branch --move OLD NEW Переименовать ветку</p>
            <p>push --set-upstream origin NEW Переименовать удаленную ветку</p>
            <p>push origin --delete OLD </p>
            <p>remote rename pb paul Переименование и Удаление удалённых репозиториев</p>
            <p>remote remove paul </p>
          </div>
        </div>

        <div class="nested-block">Псевдонимы, теги
          <div class="nested-content">
            <p>config --global alias.unstage 'reset HEAD --' Псевдоним, исключении файла из индекса </p>
            <p>config --global alias.last 'log -1 HEAD' Псевдоним, просмотреть последний коммит </p>
            <p></p>tag -a v1.4 -m "v1.4" аннотированные хранятся в бд Git как объекты. содержат имя автора, его e-mail и
            дату создания, имеют комментарий </p>
            <p></p>tag v1.4-lw легковесный </p>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="block-7" class="block content">

    <div class="block">Core

      <div class="content">

        <div class="nested-block">Типы данных JS
          <div class="nested-content">
            <p>1. Число (Number)</p>
            <p>2. String</p>
            <p>3. Boolean </p>
            <p>4. Массив (Array)</p>
            <p>5. Объект (Object)</p>
            <p>6. Undefined - не определено</p>
            <p>7. Null - пустое</p>
            <p>8. Символ (Symbol)</p>
            <p>9. Функция (Function)</p>
          </div>
        </div>

        <div class="nested-block">Как проверить является ли объект массивом?
          <div class="nested-content">
            <p>
            <p>Array.isArray(obj1)</p>
            </p>
          </div>
        </div>

        <div class="nested-block">Как проверить, является ли число конечным?
          <div class="nested-content">
            <p>isFinite() (вернет true)
            </p>
          </div>
        </div>

        <div class="nested-block">Как проверить, что переменная равна NaN?
          <div class="nested-content">
            <p>isNan() (вернет true)</p>
          </div>
        </div>

        <div class="nested-block">Чем отличается поведение isNaN() и Number.isNaN()?
          <div class="nested-content">
            <p>Метод isNaN() используется для проверки, является ли значение нечисловым (NaN).
              Однако, переданное значение будет автоматически преобразовано в число, если оно не является числом, перед
              выполнением проверки. Это означает, что метод isNaN() может вернуть true для некоторых значений, которые
              не являются NaN,
              например, для строк или пустых значений.
            </p>
          </div>
        </div>

        <div class="nested-block">var / let / const
          <div class="nested-content">
            <p> var, имеет функциональную область видимости или область видимости внутри блока кода,
              в котором она объявлена.
              Это означает, что переменная var доступна за пределами блока, в котором она объявлена,
              если она не объявлена внутри функции.
            </p>
            <p>
              Переменная, объявленная с помощью let, имеет область видимости внутри блока,
              в котором она объявлена, также известную как лексическая область видимости.
              Это означает, что переменная let не доступна за пределами блока, в котором
              она объявлена.
            </p>
            <p>
              Переменная, объявленная с помощью const, также имеет блочную область
              видимости и должна быть инициализирована при объявлении.
              Значение const переменной не может быть переназначено после инициализации,
              но сам объект или массив, на который ссылается const переменная, может быть изменен.
            </p>
          </div>
        </div>

        <div class="nested-block">Что такое область видимости?
          <div class="nested-content">
            <p>Global Scope доступны из любой части программы</p>
            <p>Local Scope внутри фунцкии, цикла и тд</p>
            <p>Block Scope введена в ES6</p>
          </div>
        </div>

        <div class="nested-block">Что такое деструктуризация
          <div class="nested-content">
            <p>Деструктуризация (Destructuring) в программировании
              - это способ извлечь значения из массивов или объектов и присвоить их переменным с помощью более
              компактного синтаксиса
              Введена с ES6
            </p>
          </div>
        </div>

        <div class="nested-block">Замыкание (closure)
          <div class="nested-content">
            <p>когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том
              случае, когда она выполняет вне своей области видимости.</p>
            <p>Замыкание технически включает три компонента:</p>
            <ul>внешняя функция, в которой определены некоторые переменные - лексическое окружение</ul>
            <ul>переменные (лексическое окружение), которые определены во внешней функции</ul>
            <ul>вложенная функция, которая использует эти переменные</ul>
          </div>
        </div>

        <div class="nested-block">Что такое деструктуризация
          <div class="nested-content">
            <p> </p>
          </div>
        </div>

      </div>
    </div>

  </div>

  <div id="block-8" class="block content">
    <div class="block">Selenium
      <div class="content">

        <div class="nested-block">Локаторы
          <div class="nested-content">
            <p>ID, Name, Class Name, Tag Name, Link Text </p>

            <p>По CSS Selector </p>
            <ul> (id): Выбирает элементы по их уникальному идентификатору.
              Пример: driver.findElement(By.cssSelector("#myElementId"));</ul>
            <ul>class: By.cssSelector(".myClass")</ul>
            <ul>attribute: By.cssSelector("[name='username']")</ul>
            <ul>tag name: By.cssSelector("div")</ul>
            <ul>По иерархии: descendant By.cssSelector("div > p")</ul>
            <ul>pseudo-classes: (By.cssSelector("input[type='checkbox']:checked")</ul>
            <ul>По комбинированным условиям: By.cssSelector("input.myClass[name='username'][type='text']"))</ul>
            <p>Приемущества:</p>
            <ul>Производительность: CSS-локаторы обычно более быстрые и эффективные в поиске элементов на странице, чем
              XPath</ul>
            <ul>Поддержка браузерами: CSS-локаторы поддерживаются всеми браузерами, xpath может быть некорректно в IE
            </ul>
            <ul>Простота и краткость? Легче читаемы</ul>
            <ul>Поддержка псевдоклассов</ul>

            <p>По XPath - XML Path Language Оси</p>

            <ul>ancestor:: — возвращает множество предков.</ul>
            <ul>ancestor-or-self:: — возвращает множество предков и текущий элемент</ul>
            <ul>child:: — возвращает множество потомков на один уровень ниже.</ul>
            <ul>descendant:: — возвращает полное множество потомков.</ul>
            <ul>following:: — возвращает необработанное множество, ниже текущего элемента.</ul>
            <ul>following-sibling:: — возвращает множество элементов на том же уровне, следующих за текущим.</ul>
            <ul>parent:: — возвращает предка на один уровень назад.</ul>
            <ul>preceding:: — возвращает множество обработанных элементов исключая множество предков.</ul>
            <ul>preceding-sibling:: — возвращает множество элементов на том же уровне, предшествующих текущему.</ul>
            <ul></ul>

          </div>
        </div>

        <div class="nested-block"> WAITS
          <div class="nested-content">
            <p>ожидания (Wait) представляют собой механизм, который позволяет автоматизированным тестам дожидаться
              определенных условий перед выполнением следующего действия. </p>
            <p>Неявные задаются один раз и автоматически применяются к каждой команде поиска элемента
              driver.manage().timeouts().implicitlyWait()
            </p>
            <p>Явные ожидания используются для ожидания определенного условия перед выполнением следующего действия.
            </p>
            <p>
              Fluent Wait (Плавающее ожидание) - это подтип явного ожидания (Explicit Wait),
              который предоставляет более гибкий и удобный способ настройки ожиданий в тестах. Он позволяет
              устанавливать несколько условий ожидания для одного элемента и выполнять дополнительные действия, когда
              условие не выполнено.</p>
            <p>FluentWait<WebDriver> wait = new FluentWait<>(driver)</p>
            <p> .withTimeout(Duration.ofSeconds(30))</p>
            <p>.pollingEvery(Duration.ofSeconds(5))</p>
            <p>.ignoring(NoSuchElementException.class)</p>
            <p>WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("myElement")))</p>
            <p></p>
            <p></p>


          </div>
        </div>

        <div class="nested-block">Приемущества css перед xpath
          <div class="nested-content">
            <p>Простота и краткость</p>
            <p>Производительность</p>
            <p>Поддержка в браузерах</p>
            <p>Знания в CSS пригодятся вам не только для автоматизации с Selenium, но и для стилизации веб-страниц</p>
            <p>Поддержка псевдоэлементов и псевдоклассов</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">pageLoadStrategy
          <div class="nested-content">
            <p>normal - ожидается document.readyState (default)</p>
            <p>eager - доступ к DOM готов,но ресурсы все еще могут загружаться (картинки)</p>
            <p>none - при переходе на новую страницу нет ожидания загрузки DOM</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p>ByCssSelector extends By.BaseW3CLocator</p>
            <p>ByXPath extends By.BaseW3CLocator</p>
            <p>ByTagName extends By.BaseW3CLocator</p>
            <p>ByPartialLinkText extends By.BaseW3CLocator</p>
            <p>ByLinkText extends By.BaseW3CLocator</p>
            <p>ByName extends By.PreW3CLocator</p>
            <p>ByClassName extends By.PreW3CLocator</p>     
            <p>ById extends By.PreW3CLocator</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

      </div>
    </div>

  </div>

  <div id="block-9" class="block content">
    <div class="block">Эффективное программирование
      <div class="content">
            
        <div class="nested-block">Типы данных
          <div class="nested-content">
            <p>Ссылочные</p>
              <ul>Интерфейсы ( в т.ч. аннотации)</ul>
              <ul>Классы (в т.ч. Enum)</ul>
              <ul>Массивы</ul>
            <p>Примитивные</p>
          </div>
        </div>

        <div class="nested-block">Приемущества / недостатки статического метода перед конструктором
          <div class="nested-content">
            <p>Приемущества</p>
              <ul>в отличие от конструкторов, он имеет название</ul>
              <ul>static не обязаны при каждом вызове создавать новый объект.</ul>
              <ul>static может возвратить объект, который соответствует не только
                заявленному типу возвращаемого значения, но и любому его подтипу</ul>
            <p>Недсотатки</p>
              <ul> недостаток использования только статических фабричных методов
                заключается в том, что классы, не имеющие открытых или защищённых конструкторов,
                не могут иметь подклассов</ul>
              <ul>их трудно отличить от других статических методов.</ul>
              <ul></ul>
          </div>
        </div>

        <div class="nested-block">Builder
          <div class="nested-content">
            <pre><code>
  public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;
        // Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }
        public Builder calories(int val) {
            calories = val;
            return this;
        }
        public Builder fat(int val) {
            fat = val;
            return this;
        }
        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }
        public Builder sodium(int val) {
            sodium = val;
            return this;
        }
        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

public class ClientCode {
  public static void main(String[] args) {
      NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).
              calories(100).sodium(35).carbohydrate(27).build();

  }
}
            </code></pre>
          </div>
        </div>

        <div class="nested-block">Singleton
          <div class="nested-content">
            <p>первый подход с открытым полем</p>
              <pre>
                <code>
public class Elvis {
  public static final Elvis INSTANCE = new Elvis();
  private Elvis() { }
  public void leaveTheBuilding() { }
}
                </code>
              </pre>
            <p>клиент с расширенными правами
              может запустить закрытый конструктор с помощью рефлексии, вызвав перед этим
              метод AccessibleObject.setAccessible. Если вы хотите защиту от такого рода атаки,
              необходимо изменить конструктор так, чтобы он выбрасывал исключение, если поступит
              запрос на создание второго экземпляра.</p>

            <p>открытый статический фабричный метод: </p>
            <pre>
              <code>
public class Elvis {
private static final Elvis INSTANCE = new Elvis();
private Elvis() { ... }
public static Elvis getInstance() { return INSTANCE; }
public void leaveTheBuilding() { ... }
}                  
              </code>
            </pre>

            <p>преимущество первого подхода (с открытым полем) заключается в том, что из
              объявления класса понятно, что этот класс является синглтоном</p>
            <p>Одно из преимуществ второго подхода (использование статического фабричного
              метода) заключается в том, что он даёт вам возможность отказаться от решения
              сделать класс синглтоном, не меняя при этом его API.</p>

              <pre>
                <code>
                  public enum Elvis {
                    INSTANCE;
                    public void leaveTheBuilding() { ... }
                    }                    
                </code>
              </pre>

              <p>Данный подход функционально эквивалентен подходу с открытым полем, за
                исключением того факта, что он более краток, бесплатно предоставляет механизм
                сериализации и даёт железную гарантию, что не будет создано более одного
                экземпляра, даже в случае замысловатых атак с использованием сериализации или
                рефлексии</p>
          </div>
        </div>

        <div class="nested-block">Контракты переопределения Equals
          <div class="nested-content">
            <ul>• Рефлексивность Для любой ненулевой ссылки х выражение x.equals(x) должно
              возвращать true
            <p>объект должен быть
              равен самому себе</p></ul>
            <ul>Симметричность: Для любых ненулевых ссылок х и у выражение x.equals(y) должно возвращать true тогда и только тогда, когда у.equals(x) возвращает
              true.
            <p>любые два объекта должны сходиться
              во мнении, равны ли они между собой</p></ul>
            <ul>• Транзитивность: Для любых ненулевых ссылок х, у и z, если х.equals(y)
              возвращает true и у.equals(z) возвращает true, то и выражение х.equals(z)
              должно возвращать true
            <p> если один объект равен второму, а второй объект равен третьему, то и первый объект
              должен быть равен третьему объекту.</p></ul>
            <ul>Непротиворечивость: Для любых ссылок х и у, если несколько раз вызвать
              х.equals(y), постоянно будет возвращаться значение true либо постоянно будет
              возвращаться значение false
            <p>если два объекта равны, они должны быть равны все время, пока один из них (или
              оба) не будет изменён</p></ul>
            <ul>Для любой ненулевой ссылки х выражение х.equals(null) должно возвращать
              false
            <p> ни один объект не может быть
              равен null</p></ul>
          </div>
        </div>

        <div class="nested-block">Контракт hashCode
          <div class="nested-content">
              <ul> hashCode должен постоянно возвращать одно и то же целое число</ul>
              <ul>Если объекты равны по equals, то у них одинаковые hashCode</ul>
              <ul>Если объекты имеют одинаковые хэши, то это не значит что они равныe</ul>
              <pre><code>
@Override public int hashCode() {
return Objects.hash(areaCode, prefix, lineNumber);
}                  
              </code></pre>
          </div>
        </div>

        <div class="nested-block">Comparator, Comparable
          <div class="nested-content">

            <pre>
              <code>
public class PhoneNumber implements Comparable&lt;PhoneNumber> {
  private final int areaCode;
  private final int prefix;
  private final int lineNumber;

  private static final Comparator&lt;PhoneNumber> COMPARATOR =
          Comparator.comparingInt((PhoneNumber pn) -> pn.areaCode)
                  .thenComparingInt(pn -> pn.prefix)
                  .thenComparingInt(pn -> pn.lineNumber);

  public PhoneNumber(int areaCode, int prefix, int lineNumber) {
      this.areaCode = areaCode;
      this.prefix = prefix;
      this.lineNumber = lineNumber;
  }

  @Override
  public int compareTo(PhoneNumber phoneNumber) {
      return COMPARATOR.compare(this, phoneNumber);
  }

  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      PhoneNumber that = (PhoneNumber) o;
      return areaCode == that.areaCode && prefix == that.prefix && lineNumber == that.lineNumber;
  }

  @Override
  public int hashCode() {
      return Objects.hash(areaCode, prefix, lineNumber);
  }

  @Override
  public String toString() {
      return "(" + areaCode + ") " + prefix + "-" + lineNumber;
  }
}
              </code>

            <p>Демо правильного использования компаратора</p>
          </div>
        </div>

        <div class="nested-block">Композиция вместо наследования
          <div class="nested-content">
            <p>Композиция позволяет добавить новую функциональность</p>
            <p>реализация разделена на две
              части: сам класс и многократно используемый класс переадресации, который содержит
              все методы переадресации и больше ничего:</p>
            <pre>
              <code>
public class InstrumentedSet&lt;E> extends ForwardingSet&lt;E> {
private int addCount = 0;
public InstrumentedSet(Set&lt;E> s) {
super(s);
}
@Override public boolean add(E e) {
addCount++;
return super.add(e);
}
@Override public boolean addAll(Collection&lt;? extends E> c) {
  addCount += c.size();
  return super.addAll(c);
}
public int getAddCount() {
return addCount;
}
} 
              </code>
            </pre>
            <pre><code>
public class ForwardingSet<E> implements Set<E> {
private final Set<E> s;
public ForwardingSet(Set<E> s) { this.s = s; }
public void clear() { s.clear(); }
public boolean contains(Object o) { return s.contains(o); } ...}
            </code></pre>

          </div>
        </div>

        <div class="nested-block">Generics определения
          <div class="nested-content">
            <ul>Параметризованный тип (parameterized type) - List&lt;String></ul>
            <ul>Обобщённый тип (generic type) - List&lt;E></ul>
            <ul>Формальный параметр типа (formal type parameter) - E</ul>
            <ul>Неограниченный подстановочный тип - Listt&lt;?></ul>
            <ul>Сырой тип (raw type) - List</ul>
            <ul>Ограниченный параметр типа
              (bounded type parameter) - &lt;E extends Number></ul>
            <ul>Рекурсивная граница типа - &lt;T extends Comparable<T>> </ul>
            <ul>Ограниченный подстановочный тип (bounded wildcard type) - List<? extends Number></ul>
            <ul>Обобщённый метод - static <E> List<E> asList(E[] a)</ul>
            <ul></ul>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

      </div>
    </div>

  </div>


  <script src="scripts/scripts.js"></script>
</body>

</html>