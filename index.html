<!DOCTYPE html>
<html>
<title>Теория для автотестера</title>
<link href="css/style.css" rel="stylesheet">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body class="container element">

  <select id="dropdown" onchange="showContent()">
    <option value="block-1">Java</option>
    <option value="block-2">Testing theory</option>
    <option value="block-3">Шаблоны, Patterns</option>
    <option value="block-4">HTML, API</option>
    <option value="block-5">БД, SQL, JDBC</option>
    <option value="block-6">Git</option>
    <option value="block-7">JavaScript</option>
    <option value="block-8">Selenium</option>
    <option value="block-9">DOCKER, LINUX</option>
    <option value="block-9">Efficient proframming</option>
  </select>

  <div id="block-1" class="block content active">

    <div class="block">ООП

      <div class="content">

        <div class="nested-block">ООП
          <div class="nested-content">
            <p>Объектно-ориентированное программирование (ООП) —
              методология программирования, основанная на представлении программы
              в виде совокупности объектов, каждый из которых является экземпляром
              определенного класса, а классы образуют иерархию наследования.</p>
            </p>
          </div>
        </div>

        <div class="nested-block">Полиморфизм
          <div class="nested-content">
            <p>это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
              структуре объекта.</p>
            <p>1 ad-hoc - перегрузка (имена методов одинаковые, а типы принимаемых аргументов разные)</p>
            <p>2 параметрический - дженерики</p>
            <p>3 полиморфизм подтипов, достигается с помощью наследование и обкаста
              это переопределение - позднее связывание</p>
          </div>
        </div>

        <div class="nested-block">В чем разница между композицией и агрегацией?
          <div class="nested-content">
            <p>Композиция и агрегация — частные случаи ассоциации «часть-целое»</p>
            <p>Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть).
              Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие,
              что экземпляр «части» может входить только в одно целое (или никуда не входить),
              в то время как в случае агрегации экземпляр «части» может входить в несколько целых.</p>
          </div>
        </div>

        <div class="nested-block">Позднее связывание
          <div class="nested-content">
            <p>сли связывание проводится компилятором (компоновщиком) перед запуском программы,
              то оно называется статическим или ранним связыванием (early binding).</p>
            <p>Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime
              binding). </p>
            <p>Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был
              объявлен
              как final, static или private (приватные методы являются final по умолчанию).</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">JVM

      <div class="content">

        <div class="nested-block">За что отвечает JVM
          <div class="nested-content">
            <p>Загрузка, проверка и исполнение байт кода;</p>
            <p> Предоставление среды выполнения для выполнения байт-кода;</p>
            <p> Управление памятью и очисткой мусора (Garbage collectio</p>
          </div>
        </div>

        <div class="nested-block">Classloader
          <div class="nested-content">
            <p>Это часть JRE, которая динамически загружает Java классы в JVM
              «по требованию», она не происходит до тех пор, пока программа не вызовет класс
              Класс с именем может быть загружен только один раз данным загрузчиком классов..</p>
            <p>
              Bootstrap class loader загружает основные библиотеки Java, JAVA_HOME/jre/lib.
              Этот загрузчик является частью ядра JVM, написан на нативном коде.
            </p>
            <p>
              Extensions class loader загружает код в каталоги расширений
              (JAVA_HOME/jre/lib/ext, или любой другой каталог, указанный системным свойством java.ext.dirs).
            </p>
            <p>
              System class loader загружает код, найденный в java.class.path,
              который сопоставляется с переменной среды CLASSPATH.
            </p>
          </div>
        </div>

        <div class="nested-block">Области данных
          <div class="nested-content">
            <p>Каждый поток в JVM имеет собственный стек</p>
            <p>heap (кучу), используется всеми потоками виртуальной машины Java.
              Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов
              классов.
              Куча создается при запуске виртуальной машины. </p>
            <p>The pc Register (PCR) Коротко говоря: для одного потока, существует один PCR, который создается при
              запуске потока.
              PCR хранит адрес выполняемой сейчас инструкции JVM.</p>
            <p>Method Area является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул
              констант,
              данные полей и методов, а также код для методов и конструкторов, включая специальные методы,
              используемые при инициализации классов и экземпляров, и инициализации интерфейса. </p>
            <p>
              Method Area хранятся все классы и статические переменные.
              Это включает информацию о структуре класса, методах, полях, интерфейсах, а также другие метаданные.
              Он является общим для всех потоков выполнения и используется для хранения информации о классах, которые
              были загружены в JVM.
            </p>
            <p>
              Native Method Stacks (Стеки нативных методов):
              Как и у Java-потоков, каждый нативный метод (написанный на языках, отличных от Java,
              и вызываемый через JNI) имеет свой собственный стек нативного метода.
              Этот стек используется для хранения локальных переменных и информации о вызовах нативных методов.
            </p>
          </div>
        </div>

        <div class="nested-block">Frames
          <div class="nested-content">
            <p>Frame используется для хранения данных и частичных результатов, а также для выполнения динамического
              связывания,
              возврата значений и отправки исключений. Новый frame создается каждый раз, когда вызывается метод.
              и уничтожается, когда завершается вызов метода</p>
          </div>
        </div>
      </div>
    </div>

    <div class="block">CORE, CLASS, INTERFACE

      <div class="content">

        <div class="nested-block">интерфейс
          <div class="nested-content">
            <p>Интерфейсы в Java - это механизм, который позволяет определить абстрактный тип данных,
              состоящий только из сигнатур методов и константных полей, но без их реализации</p>
            <p>Абстрактные методы: должны быть реализованы классами, которые реализуют интерфейс.</p>
            <p>Константные поля: автоматически считаются public, static и final.</p>
            <p>public и abstract методы: автоматически, модификаторы можно опустить</p>
            <p>Java 8: (default methods) + (static methods)</p>
            <p>Java 9: private methods</p>
            <p>Java 11: private static methods</p>
          </div>
        </div>

        <div class="nested-block">абстрактный класс VS интерфейс
          <div class="nested-content">
            <p>Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является).
              Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</p>
            <p>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для
              частичной реализации поведения.
              Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности</p>
          </div>
        </div>

        <div class="nested-block">порядок вызова конструкторов и блоков инициализации
          <div class="nested-content">
            <p>Parent static block(s) → Child static block(s) </p>
            <p>Parent non-static block(s) → Parent constructor</p>
            <p> Child non-static block(s) → Child constructor</p>
          </div>
        </div>

        <div class="nested-block">Nested (Вложенные классы)
          <div class="nested-content">
            <p>Вложенные статические классы объявляются с ключевым словом static и, как следствие,
              не имеют доступа к нестатическим членам (полей и методам) внешнего класса.
              Использоваться, когда логически связанный класс нужно скрыть внутри внешнего класса.</p>
            <p>Внутренние классы (Inner Classes): имеют доступ к нестатическим членам внешнего класса, включая его
              приватные члены.
              Они имеют доступ к своему внешнему экземпляру, что позволяет установить более тесную связь с внешним
              классом.
              Внутренние классы бывают:</p>
            <p>Анонимные классы (Anonymous Classes): создаются без явного объявления имени класса.
              Они обычно используются для создания одноразовых экземпляров класса, который реализует интерфейс или
              расширяет абстрактный класс.</p>
            <p>Локальные классы (Local Classes) объявляются внутри блоков кода (например, методов) и имеют доступ к
              локальным переменным этого блока кода.
              Они обычно используются для создания классов, которые должны быть видны только внутри ограниченной области
              их объявления.</p>
          </div>
        </div>

        <div class="nested-block">переменные в методы, по значению или по ссылке?
          <div class="nested-content">
            <p>«скопировать значение и передать копию». С примитивами это будет копия содержимого.
              Со ссылками - тоже копия содержимого, т.е. копия ссылки.</p>
          </div>
        </div>

        <div class="nested-block">final, finally и finalize()?
          <div class="nested-content">
            <p>Модификатор final:</p>
            <p>Класс не может иметь наследников;</p>
            <p>Метод не может быть переопределен в классах наследниках;</p>
            <p>Поле не может изменить свое значение после инициализации;</p>
            <p>Локальные переменные не могут быть изменены после присвоения им значения;</p>
            <p>Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от того,
              какие исключения были возбуждены и перехвачены в блоке try-catch.</p>
            <p>Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>
          </div>
        </div>

        <div class="nested-block">приведение типов.
          <div class="nested-content">
            <p>Расширение (повышение, upcasting) примитивного типа (widening primitive).</p>
            <p> Означает, что осуществляется переход от менее емкого типа к более ёмкому.
              byte -> int (длина 4 байта).</p>
            <p>Сужение (понижение, downcasting) примитивного типа (narrowing primitive</p>
            <p>Расширение объектного типа (widening reference)</p>
            <p> переход от потомка к предку. Разрешено всегда и происходит автоматически.</p>
            <p> Возможно только если исходная переменная является подтипом приводимого типа.
              При несоответствии типов в момент выполнения выбрасывается исключение ClassCastException.
              Требует явного указания типа.</p>
          </div>
        </div>

        <div class="nested-block">autoboxing («автоупаковка»)
          <div class="nested-content">
            <p>Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, Integer, Long,
              Float, Double, Character, Boolean)
              значениями соответствующих им исходных примитивных типов (byte, short, int...), без явного использования
              конструктора класса.</p>
          </div>
        </div>

        <div class="nested-block">Object
          <div class="nested-content">
            <p> equals(Object obj) для сравнения объектов по значению;</p>
            <p>hashCode() – возвращает hash код для объекта;</p>
            <p>toString() – возвращает строковое представление объекта;</p>
            <p>getClass() – возвращает класс объекта во время выполнения;</p>
            <p>clone() – создает и возвращает копию объекта;</p>
            <p>notify() – возобновляет поток, ожидающий монитор;</p>
            <p>notifyAll() – возобновляет все потоки, ожидающие монитор;</p>
            <p>ait() – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify()
              или notifyAll() для этого объекта;</p>
            <p>finalize() – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
          </div>
        </div>

        <div class="nested-block">Переопределение equals():
          <div class="nested-content">
            <p>на равенство ссылок (this == obj).
              Если объекты ссылаются на одну и ту же область памяти, они должны считаться равными. </p>
            <p>Проверка на тип объекта</p>
            <p>Сравнивайте значения всех полей</p>
            <p>if (this == obj) return true;
              if (obj == null || getClass() != obj.getClass()) return false;
              MyClass other = (MyClass) obj;
              return field1 == other.field1 &&
              Objects.equals(field2, other.field2) &&
              Objects.equals(field3, other.field3);</p>
          </div>
        </div>

        <div class="nested-block">Переопределение hashCode():
          <div class="nested-content">
            <p>@Override
              public int hashCode() {
              return Objects.hash(field1, field2, field3);
              }</p>
          </div>
        </div>


      </div>
    </div>

    <div class="block">String

      <div class="content">

        <div class="nested-block">Почему строка является популярным ключом в HashMap в Java?
          <div class="nested-content">
            <p>Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания,
              не требуя повторного пересчета при дальнейшем использовании.
              Поэтому в качестве ключа HashMap они будут обрабатываться быстрее.</p>
          </div>
        </div>

        <div class="nested-block">разница между String, StringBuffer, StringBuilder?
          <div class="nested-content">
            <p>Класс String является неизменяемым (immutable) -
              модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</p>
            <p>StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать
              содержимое</p>
            <p>StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того,
              что он не синхронизирован и поэтому его методы выполняются значительно быстрей.</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">COLLECTIONS

      <div class="content">

        <div class="nested-block">основные интерфейсы
          <div class="nested-content">
            <p>«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть
              числа, строки, объекты пользовательских классов и т.п</p>
            <p>Интерфейс Collection расширяют интерфейсы:</p>

            <ul>List (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Реализации</ul>
            <li>ArrayList - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при
              добавлении новых элементов.
              Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.</li>
            <li>LinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как
              собственно данные,
              так и две ссылки на следующий и предыдущий узел.</li>
            <li>Vector — реализация динамического массива объектов, методы которой синхронизированы.</li>
            <ul>Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:</ul>
            <li>HashSet - использует HashMap для хранения данных. В качестве ключа используется добавляемый элемент,
              в качестве значения - заглушка Object.
              Из-за особенностей реализации порядок элементов не гарантируется при добавлении.</li>
            <li>LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку
              добавления элементов.</li>
            <li>TreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта
              Comparator, либо сохраняет элементы с использованием «natural ordering».
              <ul>Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения
                FIFO (first-in-first-out):</ul>
            <li>PriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта
              Comparator,
              либо сохраняет элементы с использованием «natural ordering».</li>
            <li>ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами,
              позволяющими реализовать конструкцию вида LIFO last-in-first-out</li>
            <li></li>

            <p>Интерфейс Map реализован классами:</p>
            <li>Hashtable — хэш-таблица, методы которой синхронизированы.
              Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.</li>
            <li>HashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является
              упорядоченной.</li>
            <li>LinkedHashMap — упорядоченная реализация хэш-таблицы.</li>
            <li>TreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет
              возможность управлять порядком элементов в коллекции при помощи объекта Comparator,
              либо сохраняет элементы с использованием «natural ordering».</li>
          </div>
        </div>

        <div class="nested-block">Как между собой связаны Iterable и Iterator?
          <div class="nested-content">
            <p>Интерфейс Iterable имеет только один метод - iterator(), который возвращает Iterator.</p>
          </div>
        </div>

        <div class="nested-block">Как поведёт себя коллекция, если вызвать iterator.remove()?
          <div class="nested-content">
            <p>Если вызову iterator.remove() предшествовал вызов iterator.next(), то iterator.remove() удалит элемент
              коллекции,
              на который указывает итератор, в противном случае будет выброшено IllegalStateException().</p>
          </div>
        </div>

        <div class="nested-block">Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в
          каких второй?
          <div class="nested-content">
            <ul>ArrayList:</ul>
            <li>доступ к произвольному элементу по индексу за константное время O(1);</li>
            <li>доступ к элементам по значению за линейное время O(N);</li>
            <li>вставка в конец в среднем производится за константное время O(1);</li>
            <li>удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы,
              находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);
            </li>
            <li>вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы,
              находящиеся «правее» смещаются на одну ячейку вправо;</li>
            <li>минимум накладных расходов при хранении.</li>
            <ul>LinkedList:</ul>
            <li>на получение элемента по индексу или значению потребуется линейное время O(N);</li>
            <li>но доступ к первому и последнему элементу списка всегда осуществляется за константное время O(1)
              — ссылки постоянно хранятся на первый и последний элемент;</li>
            <li>на добавление и удаление в начало или конец списка потребуется константное O(1);</li>
            <li>вставка или удаление в/из произвольного место константное O(1);</li>
            <li>но поиск позиции вставки и удаления за линейное время O(N);</li>
            <li>требует больше памяти для хранения такого же количества элементов,
              потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</li>
          </div>
        </div>

        <div class="nested-block">HashMap принцип работы
          <div class="nested-content">
            <p>Принцип работы HashMap:</p>

            <ul>1. Хеширование ключей </ul>
            <li>Когда вы добавляете элемент в HashMap с помощью метода put(key, value), сначала вычисляется хеш-код
              ключа key с помощью метода hashCode() объекта ключа
              Затем вычисляется индекс массива, в который будет помещен элемент.</li>

            <ul>2. поиск индекса:</ul>
            <li>Если в результате корзина занята (т.е. произошла коллизия),
              Ключи сверяются по equals (если равны - перезаписывается значение, если нет -
              произошла коллизия

              <ul>3. Разрешение коллизий:</ul>
            <li> новый элемент добавляется в конец связанного списка (цепочки) для этой корзины. В Java 8 и выше, когда
              коллизии часто возникают,
              вместо списка может использоваться бинарное дерево для улучшения производительности поиска.</li>

            <ul>Динамическое изменение размера:</ul>
            <li>После добавления элемента, HashMap проверяет, не превышает ли количество элементов в коллекции
              определенное значение, которое связано с фактором загрузки (load factor)
              количество элементов / размер массива (обычно от 0.5 до 0.75).
              Когда количество элементов в одной корзине превышает определенный предел (обычно 8),
              Java (8+) преобразует связанный список в бинарное дерево.
            </li>
          </div>
        </div>

        <div class="nested-block">HashСode
          <div class="nested-content">
            <p>- метод Object, возвращает 32-битовое значение.
              Рассчитывается hashCode() по умолчанию на основе адреса объекта в памяти,
              Важно переопределить метод hashCode() для классов, используемых в качестве ключей в HashMap.
              Когда объекты равны с точки зрения equals(),
              их хеш-коды должны быть одинаковыми, чтобы они попали в одну и ту же корзину в хеш-таблице.
            </p>
          </div>
        </div>

        <div class="nested-block">Бинарное дерево (Binary Tree)
          <div class="nested-content">
            <p>это структура данных, состоящая из узлов, где каждый узел содержит три элемента: значение (ключ), левого
              потомка и правого потомка. Каждый узел в бинарном дереве имеет не более двух потомков:
              левого потомка и правого потомка, которые, в свою очередь, также могут быть бинарными деревьями.</p>
            <p>Преимущества бинарного дерева над связанным списком заключаются в том, что время поиска элемента в дереве
              логарифмическое, O(log n), вместо линейного, O(n), как в связанном списке</p>

          </div>
        </div>

        <div class="nested-block">LinkedHashMap
          <div class="nested-content">
            <p>Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязанного списка,
              определяющего порядок итерации по элементам структуры данных.
              По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order).
              Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true.
              В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order).
              Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец
              списка.</p>
          </div>
        </div>

        <div class="nested-block">Как перебрать все ключи \ значения Map?
          <div class="nested-content">
            <p>Использовать метод keySet(), который возвращает множество Set<K> ключей.</p>
            <p>Использовать метод values(), который возвращает коллекцию Collection<V> значений.</p>
          </div>
        </div>

        <div class="nested-block">Как перебрать все пары «ключ-значение» в Map?
          <div class="nested-content">
            <p>for (Map.Entry<String, Integer> entry : map.entrySet()) </p>
            <p> String key = entry.getKey();</p>
            <p>Integer value = entry.getValue();</p>
          </div>
        </div>


        <div class="nested-block">В чем отличия TreeSet и HashSet?
          <div class="nested-content">
            <p>TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.
              Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).</p>
            <p>HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием,
              что в HashSet в качестве ключа и значения выступает сам элемент, кроме того, HashSet не поддерживает
              упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично
              HashMap.</p>
          </div>
        </div>


        <div class="nested-block">Как получить коллекцию только для чтения?
          <div class="nested-content">
            <p>Collections.unmodifiableList(list);</p>
            <p>Collections.unmodifiableSet(set);</p>
            <p>Collections.unmodifiableMap(map).</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Java 8, Лямбда, FUNCTIONAL INTARFACE

      <div class="content">

        <div class="nested-block">Лямбда выражения
          <div class="nested-content">
            <p> Лямбда-выражения представляют собой компактный способ представления анонимных функций,
              которые могут быть использованы в качестве аргументов методов или возвращаемых значений.</p>
            <p>Function<Integer, Integer> square = x -> x * x;</p>
            <p>BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;</p>
            <p>Лямбда-выражения часто используются вместе с функциональными интерфейсами, такими как Runnable, Consumer,
              Predicate, Function и другими, которые определены в пакете java.util.function.
              Эти интерфейсы предоставляют предопределенные абстрактные методы, которые могут быть реализованы с помощью
              лямбда-выражений</p>


            <p>Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->.
              Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения,
              а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.
            </p>
            <p>interface Operationable {</p>
            <p>int calculate(int x, int y); }</p>
            <p>public static void main(String[] args) {</p>
            <p>Operationable operation = (x, y) -> x + y; </p>
            <p>int result = operation.calculate(10, 20);}</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Что такое «ссылка на метод»?
          <div class="nested-content">
            <p>имя_класса::имя_статического_метода для статического метода;</p>
            <p>объект_класса::имя_метода для метода экземпляра;</p>
            <p>название_класса::new для конструктора.</p>
            <p>Measurable a = String::length;</p>
          </div>
        </div>

        <div class="nested-block">Что такое «функциональные интерфейсы»?
          <div class="nested-content">
            <p>Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.</p>
            <p>Чтобы точно определить интерфейс как функциональный, добавлена аннотация @FunctionalInterface, работающая
              по принципу @Override.
              Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.</p>
            <p>Интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что
              default методы - не абстрактные.</p>
          </div>
        </div>

        <div class="nested-block">функциональные интерфейсы Function<T,R>, UnaryOperator<T>?
              <div class="nested-content">
                <p>Function<T,R> интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса
                    T и возвращающая на выходе экземпляр класса R.</p>
                <p>Function<String, Integer> toInteger = Integer::valueOf;</p>
                <p>UnaryOperator<T>(унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними
                    операции и возвращает результат операций в виде объекта типа T:</p>
                <p>UnaryOperator<Integer> operator = x -> x * x;</p>
                <p>BinaryOperator<T>- интерфейс, с помощью которого реализуется функция, получающая на вход два
                    экземпляра класса T и возвращающая на выходе экземпляр класса T.</p>
                <p>BinaryOperator<Integer> operator = (a, b) -> a + b;</p>
                <p>Predicate<T>интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T
                    и возвращающая на выходе значение типа boolean.</p>
                <p>Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or,
                  negate).</p>
                <p>Predicate<String> predicate = (s) -> s.length() > 0;</p>
                <p>Consumer<T> (потребитель) - интерфейс, с помощью которого реализуется функция, которая получает на
                    вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает.</p>
                <p>Consumer<String> hello = (name) -> System.out.println("Hello, " + name);</p>
                <p>Supplier<T> (поставщик) - интерфейс, с помощью которого реализуется функция, ничего не принимающая на
                    вход, но возвращающая на выход результат класса T;</p>
                <p>Supplier<LocalDateTime> now = LocalDateTime::now;</p>
              </div>
        </div>

        

      </div>
    </div>

    <div class="block">EXCEPTIONS

      <div class="content">

        <div class="nested-block">EXCEPTIONS иерархия
          <div class="nested-content">
            <p>общий предок — класс Throwable</p>
            <p>Exception и Error (OutOfMemoryError, StackOwerflow)</p>
            <p>Exception имеет предков RuntimeException (Unchecked)</p>
              <ul>ArithmeticException: исключение, возникающее при делении на ноль</ul> 
              <ul>IndexOutOfBoundException: индекс вне границ массива</ul>
              <ul>ClassCastException, NoSuchElementException</ul>
            <p>checked</p>
              <ul>ClassNotFoundException: невозможно найти класс</ul>
              <ul>IOException</ul>
              <ul>FileNotFoundException</ul>
              <ul>SQLException</ul>
          </div>
        </div>

        <div class="nested-block">return всегда finnaly 
          <div class="nested-content">
            <pre><code>
  try {
    int result = 10 / 0;
    return 1;
} catch (ArithmeticException e) {
    return 2;
} finally {
    return 3;
}
            </code></pre>
            <p>Метод вернет 3 в любом случае, т.к. блок отрабатывает всегда последним</p>
          </div>
        </div>

        <div class="nested-block">OutOfMemoryError
          <div class="nested-content">
            <p>java.lang.OutOfMemoryError: Java heap space</p>
            <p>java.lang.OutOfMemoryError: Metaspace (для Java 8 и более новых версий):
              Этот вид связан с исчерпанием места в PermGen (для Java 7 и ранее) или Metaspace (для Java 8 и новее), которые используются для хранения метаданных классов и другой JVM-информации.</p>
            <p>java.lang.OutOfMemoryError: Requested array size exceeds VM limit программа пытается создать массив, размер которого превышает максимальный предел, установленный в JVM</p>
            <p>java.lang.OutOfMemoryError: unable to create new native thread:
              Этот вид возникает, когда JVM не может создать новый поток из-за ограниченных ресурсов операционной системы.</p>
            <p>Можно настроить параметры JVM, такие как размер Java heap (-Xmx и -Xms), размер PermGen или Metaspace, размер стека потоков и т.д., чтобы адаптировать их под требования вашей программы</p>
          </div>
        </div>



      </div>
    </div>

    <div class="block">Многопоточность

      <div class="content">

        <div class="nested-block">Процесс, Поток, синхронизация потоков (synchronized)
          <div class="nested-content">
            <p>Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство. 
              Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен</p>
              <p>Один поток («нить» или «трэд») – это одна единица исполнения кода</p>
              <p>Синхронизация — это процесс, который позволяет выполнять все параллельные потоки в программе синхронно.</p>
              <p>Когда метод объявлен как синхронизированный — нить держит монитор для объекта, метод которого исполняется. 
                Если другой поток выполняет синхронизированный метод, ваш поток заблокируется до тех пор, 
                пока другой поток не отпустит монитор.</p>
          </div>
        </div>

        <div class="nested-block">Каким образом можно создать поток?
          <div class="nested-content">
            <p>1. Создать потомка класса Thread и переопределить его метод run();</p>
            <p> Затем создается экземпляр этого класса и запускается метод start(), который инициирует выполнение
              потока.</p>
            <p>2 public class MyRunnable implements Runnable {</p>
            <p>public void run() {}</p>
            <p> public static void main(String[] args) {</p>
            <p>MyRunnable myRunnable = new MyRunnable();</p>
            <p>Thread thread = new Thread(myRunnable);</p>
            <p> thread.start();</p>
            <p>Создать объект класса, реализующего интерфейс Callable</p>
            <p>Создать объект ExecutorService с указанием пула потоков.</p>
            <p>Создать объект Future. Запуск происходит через метод submit(); Сигнатура: <T> Future<T> submit(Callable<T> task)</p>
            <p></p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Start(), submit(),  run(), call()
          <div class="nested-content">
            <p>Thread.start() запускает дочерний поток.</p>
            <p>submit() Для интерфейса Callable запуск потока осуществляется с помощью метода .</p>
            <p>Метод run() или метод call() для дочерних потоков  описывает действие потока во время выполнения</p>
            <p> main() описывает действие для главного потока</p>
          </div>
        </div>

        <div class="nested-block">Как принудительно остановить поток
          <div class="nested-content">
            <p>Никто не гарантирует, что нить можно остановить.</p>
            <p>Класс Thread содержит в себе скрытое булево поле, которое называется флагом прерывания. Установить этот флаг можно вызвав метод interrupt() потока</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Состояния потока
          <div class="nested-content">
            <p>NEW, RUNNABLE, BLOCKED, TERMINATED, WAITING, TIMED_WAITING</p>
          </div>
        </div>

        <div class="nested-block">notify и notifyAll
          <div class="nested-content">
            <p>Метод notify пробуждает один из потоков, который вызвал метод wait() у этого монитора. Метод notifyAll пробуждает все потоки. 
              Очередность выполнения в этом случае будет определяться приоритетом потока.</p>
          </div>
        </div>
        

        <div class="nested-block">Что такое «монитор» мьютекс (mutex)?
          <div class="nested-content">
            <p>это средство обеспечения контроля за доступом к ресурсу.
              У монитора может быть максимум один владелец в каждый текущий момент времени.
              Следовательно, если кто-то использует ресурс и захватил монитор для обеспечения единоличного доступа,
              то другой, желающий использовать тот же ресурс,
              должен подождать освобождения монитора, захватить его и только потом начать использовать ресурс.</p>
          </div>
        </div>

        <div class="nested-block">Состояния потока
          <div class="nested-content">
            <p>Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван
              метод start().</p>
            <p>Работоспособный (Runnable). когда вызывается метод start(). </p>
            <p>Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий,
              когда Планировщик потоков выбирает его как работающий в данный момент.</p>
            <p>Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по
              нескольким причинам:</p>
            <ul>Ожидание (Waiting).ия, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из
              состояния Ожидания в состояние Работоспособный.</ul>
            <ul>Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в
              миллисекундах.</ul>
            <ul>Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или
              из-за блокировки другого объекта. </ul>
            <ul>Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен.</ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">STREAM

      <div class="content">

        <div class="nested-block">Что такое Stream?
          <div class="nested-content">
            <p>последовательность элементов, над которой можно производить промежуточные (intermediate) или конечные
              (terminal). операции.</p>
            <p>Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же
              стрим.</p>
            <p>Стримы создаются на основе каких-либо источников, например классов из java.util.Collection</p>
          </div>
        </div>

        <div class="nested-block">способы создания стрима?
          <div class="nested-content">
            <p>Из коллекции:</p>
            <p>Stream<String> fromCollection = Arrays.asList("x", "y", "z").stream();</p>
            <p>Из набора значений:</p>
            <p>Stream<String> fromValues = Stream.of("x", "y", "z");</p>
            <p>Из массива:</p>
            <p>Stream<String> fromArray = Arrays.stream(new String[]{"x", "y", "z"});</p>
            <p>Из файла (каждая строка в файле будет отдельным элементом в стриме):</p>
            <p>Stream<String> fromFile = Files.lines(Paths.get("input.txt"));</p>
            <p>Из строки:</p>
            <p>IntStream fromString = "0123456789".chars();</p>
            <p>С помощью Stream.builder():</p>
            <p>Stream<String> fromBuilder = Stream.builder().add("z").add("y").add("z").build();</p>
            <p>С помощью Stream.iterate() (бесконечный):</p>
            <p>Stream<Integer> fromIterate = Stream.iterate(1, n -> n + 1);</p>
            <p>С помощью Stream.generate() (бесконечный):</p>
            <p>Stream<String> fromGenerate = Stream.generate(() -> "0");</p>
          </div>
        </div>

        <div class="nested-block"> промежуточные методы
          <div class="nested-content">
            <p>findFirst() возвращает первый элемент;</p>
            <p>findAny() возвращает любой подходящий элемент;</p>
            <p>collect() представление результатов в виде коллекций и других структур данных;</p>
            <p>count() возвращает количество элементов;</p>
            <p>anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;</p>
            <p>noneMatch() возвращает true, если условие не выполняется ни для одного элемента;</p>
            <p>allMatch() возвращает true, если условие выполняется для всех элементов;</p>
            <p>min() возвращает минимальный элемент, используя в качестве условия Comparator;</p>
            <p>max() возвращает максимальный элемент, используя в качестве условия Comparator;</p>
            <p>forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);</p>
            <p>forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;</p>
            <p>toArray() возвращает массив значений;</p>
            <p>reduce()позволяет выполнять агрегатные функции и возвращать один результат.</p>
            <p>sum() возвращает сумму всех чисел;</p>
            <p>average() возвращает среднее арифметическое всех чисел.</p>
          </div>
        </div>

        <div class="nested-block"> конечные методы
          <div class="nested-content">
            <p>filter() отфильтровывает записи, возвращая только записи, соответствующие условию;</p>
            <p>skip() позволяет пропустить определённое количество элементов в начале;</p>
            <p>distinct() возвращает стрим без дубликатов (для метода equals());</p>
            <p>map() преобразует каждый элемент;</p>
            <p>peek() возвращает тот же стрим, применяя к каждому элементу функцию;</p>
            <p>limit() позволяет ограничить выборку определенным количеством первых элементов;</p>
            <p>sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;</p>
          </div>
        </div>

        <div class="nested-block">collect()
          <div class="nested-content">
            <pre><code> &lt;R, A> R collect(Collector&lt;? super T, A, R> collector)</code></pre>
            <p>принимает объект класса Collector, который определяет, как собрать элементы потока в конечный результат.</p>
            <pre><code> &lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)</code></pre>
            <ul>supplier: Это функция-поставщик, создает начальное состояние аккумулятора.
              Аккумулятор - это место, куда мы будем добавлять элементы потока по мере их обработки. 
              Например, ArrayList::new для создания списка.</ul>
            <ul>accumulator: Это функция-аккумулятор, которая принимает текущее состояние аккумулятора и следующий элемент из потока.
                Эта функция обновляет аккумулятор, добавляя элемент в него. Например, List::add для списка.</ul>
            <ul>combiner: Эта функция-комбинатор используется только в параллельных потоках. 
              Она объединяет результаты работы нескольких аккумуляторов в один. 
              Например, если вы обрабатываете поток параллельно и имеете несколько аккумуляторов, combiner объединяет их результаты.</ul>
          </div>
        </div>

        <div class="nested-block">Collector
          <div class="nested-content">
              <p>Простые агрегации</p>
            <ul>toCollection(HashSet::new) </ul>
            <ul>toList(), toSet(), toMap(keyMapper, valueMapper)</ul>
            <ul>counting()</ul>
              <pre><code>
                .collect(Collectors.groupingBy(
                Exam.ExamResult::getGrade,
                Collectors.counting()
                ));</code></pre>
            <ul>summingInt(mapper), summingLong(mapper), summingDouble(mapper), averagingInt(mapper), averagingLong(mapper), averagingDouble(mapper)</ul>  
            <ul>maxBy(comparator), minBy(comparator)</ul>  
            <ul>reducing(identity, mapper, binaryOperator), reducing(binaryOperator), reducing(identity, binaryOperator)</ul>  
            <ul>collectingAndThen(downstream, finisher)</ul>  
              <p>Множественная агрегация: mapping(mapper, downstream</p>
            <p>Группировка groupingBy</p> 
            <p>Разделение partitioningBy</p> 
            <p> Соединение - joining(delimiter)</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>


      </div>
    </div>

    <div class="block">Reflection

      <div class="content">

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>


      </div>
    </div>

  </div>

  <div id="block-2" class="block content">

    <div class="block">ТЕСТИРОВАНИЕ: Цели, принципы, процесс, Модели разработки, документация 
      <div class="content">


        <div class="nested-block">Цели тестирования
          <div class="nested-content">
            <p>Оценку требований, юзер сторей, проектирования и кода</p>
            <p>Проверку, все ли указанные требования выполнены</p>
            <p>Обнаружение  дефектов</p>
            <p>Предотвращение дефектов</p>
            <p>Снижение уровня риска ненадлежащего качества продукта</p>
          </div>
        </div>

        <div class="nested-block">Семь принципов тестирования
          <div class="nested-content">
            <p>Тестирование демонстрирует наличие дефектов, а не их отсутствие</p>
            <p>Исчерпывающее тестирование недостижимо</p>
            <p>Раннее тестирование сохраняет время и деньги</p>
            <p>Кластеризация дефектов (Обычно небольшое количество модулей содержит большинство дефектов, на них надо фокусироваться)
            </p>
            <p>Парадокс пестицида - Если одни и те же тесты будут выполняться снова и снова, в конечном счете эти тесты больше
              не будут находить новых дефектов (необходимо изменять их).</p>
            <p>Тестирование зависит от контекста (где-то упор на безопасности, где то на важно мобилки)</p>
            <p>Заблуждение об отсутствии ошибок</p>
          </div>
        </div>

        <div class="nested-block">Процесс тестирования
          <div class="nested-content">
            <p>Планирование тестирования</p>
            <p>Мониторинг и контроль тестирования</p>
            <p>Анализ тестирования</p>
            <p>Проектирование тестов</p>
            <p>Реализация тестов</p>
            <p>Выполнение тестов</p>
            <p>Завершение тестирования</p>
          </div>
        </div>

        <div class="nested-block">Жизненный цикл тестирования
          <div class="nested-content">
            <ul>Общее планирование и анализ требований</ul>
            <ul>Уточнение критериев приемки</ul>
            <ul>Уточнение стратегии тестирования</ul>
            <ul>Разработка тест кейсов</ul>
            <ul>Выполнение тест кейсов</ul>
            <ul>Фиксация найденных деффектов</ul>
            <ul>Анализ результатов тестирования</ul>
            <ul>Отчетность</ul>
          </div>
        </div>

        <div class="nested-block">Модели разработки ПО
          <div class="nested-content">
            <p>Модель разработки ПО (Software Development Model, SDM) — структура,
              систематизирующая различные виды проектной деятельности, их взаимодействие и последовательность в процессе
              разработки ПО. </p>

            <p>Водопадная модель:</p>
            <p>(подготовка)</p>
            <ul>Общее планирование -> Пользовательские требования -> системные требования -> тех архитектура -> дизайн
            </ul>
            <p>(Разработка и тестирование)</p>
            <ul>Разработка и отладка</ul>
            <ul>Интеграция и модульные (юнит) тестирование</ul>
            <ul>Инсталляционное тестирование</ul>
            <ul>Системное тесторование</ul>
            <ul>Приемочное тестирование</ul>
            <ul>Итоговое тестирование</ul>

            <p>V-образная модель:</p>
            <p>при использовании v-образной модели
              на каждой стадии «на спуске» нужно думать о том, что и как будет происходить на
              соответствующей стадии «на подъёме». Тестирование здесь появляется уже на самых ранних стадиях развития
              проекта, что позволяет минимизировать риски, а
              также обнаружить и устранить множество потенциальных проблем до того, как они
              станут проблемами реальными.</p>
            <ul>Спуск:
              >Общее планирование -> Пользовательские требования -> системные требования -> тех архитектура -> дизайн
            </ul>
            <ul>Разработка и отладка -> Интеграция и модульные (юнит) тестирование -> Инсталляционное тестирование ->
              Системное тесторование -> Приемочное тестирование -> Итоговое тестирование
            </ul>

            <p>Итерационная инкрементальная модель</p>
            <p> точки зрения жизненного цикла модель является итерационной, т.к. подразумевает многократное повторение
              одних и тех же стадий;</p>
            <p>На входе общее планирование</p>
            <ul>планирование + требования</ul>
            <ul>архитектура и дизайн</ul>
            <ul>разработка и отладка</ul>
            <ul>интеграция и модульные тесты</ul>
            <ul>Установка билда</ul>
            <ul>Тестирование</ul>
            <ul>Оценка результатов</ul>
            <ul>Отчетность</ul>
            <p>Итоговая отчетность</p>


            <p>Спиральная модель (spiral model30) представляет собой частный случай
              итерационной инкрементальной модели, в котором особое внимание уделяется
              управлению рисками, в особенности влияющими на организацию процесса разработки проекта и контрольные
              точки.</p>

            <p>Гибкая модель (agile model35) представляет собой совокупность различных
              подходов к разработке ПО и базируется на т.н. «agile-манифесте»36:
            </p>
            <ul>Люди и взаимодействие важнее процессов и инструменто</ul>
            <ul>Работающий продукт важнее исчерпывающей документации</ul>
            <ul>Сотрудничество с заказчиком важнее согласования условий контракта.</ul>
            <ul>Готовность к изменениям важнее следования первоначальному плану</ul>
            <ul></ul>

            <p>scrum </p>
            <p>Роли</p>
            <ul>Product owner: управляет бэклогом, принимает работу, определяет дату релиза</ul>
            <ul>scrum master: ответственный за выполнение скрап процессов помогает овнеру</ul>
            <ul>Dev + BA + testers</ul>
            <p>События спринта:</p>
            <p>Planning</p>
            <ul>Owner определяет бизнес-задачи спринта, отбирает таски из Бэклога</ul>
            <ul>Developers определяют количесво тасок</ul>
            <ul>Developers оценивает в стори поинтах</ul>
            <ul>Решается кто и какие задачи будет выполнять</ul>
            <ul>В результате создается бэклог спринта</ul>
            <p>Daily</p>
            <ul>Что сделал вчера, что делаю сегодня, какие есть блокеры</ul>
            <p>sprint review</p>
            <ul>Фокус на результат спринта а не процесс</ul>
            <ul>Rjvfylf ghtlcnfdkztn xnj ,skj cltkfyj</ul>
            <p>Demo</p>
            <ul>Может быть частью sprint review</ul>
            <p>Sprint review</p>
            <ul>Что было сделано хорошо, что можно улучшить</ul>

            <p>Kanban</p>
            <ul>Опирается на визуализацию (на доске, на стене)</ul>
            <ul>Ограничение работ выполняемых одновременно</ul>

            <p>Отличия scrum от kanban</p>
            <ul>Принципы и методология:

              Scrum: Scrum основан на итеративном и инкрементальном подходе к разработке. Работа организована в сроки,
              называемые спринтами (обычно от 1 до 4 недель). Каждый спринт начинается с планирования и заканчивается
              обзором и ретроспективой.
              Kanban: Kanban основан на принципе непрерывного потока работы. Задачи представлены в виде карточек на
              доске, где каждая карточка представляет определенную работу. Отличительной чертой Kanban является
              отсутствие фиксированных временных рамок (спринтов).</ul>
            <ul>Итерации и планирование:

              Scrum: В Scrum работа организована в спринтах, и каждый спринт имеет фиксированную продолжительность.
              Планирование происходит на каждом спринте, и изменения обычно вносятся только между спринтами.
              Kanban: В Kanban нет спринтов и фиксированных итераций. Задачи обрабатываются непрерывно, и новые задачи
              могут быть добавлены в доску в любое время.</ul>
            <ul>Команды и роли:

              Scrum: Scrum имеет определенные роли, такие как Scrum Master, Product Owner и разработчики. Scrum Master
              отвечает за процесс, Product Owner за управление требованиями, а разработчики за создание продукта.
              Kanban: В Kanban роли часто более гибкие и не так формализованы. Обычно нет Scrum Master или Product
              Owner. Каждый член команды может участвовать в управлении процессом.</ul>
            <ul>Отслеживание прогресса:

              Scrum: Прогресс отслеживается через бурндаун-чарт, который показывает, сколько работы осталось в спринте.
              Kanban: Прогресс отслеживается через циклы обработки задач и поток работы на доске.</ul>
            <ul>Планирование и приоритизация:

              Scrum: Приоритеты задач определяются на начало спринта. Задачи планируются до начала спринта и защищаются
              от изменений на протяжении спринта.
              Kanban: Приоритеты задач могут меняться в любое время. Задачи могут быть добавлены или удалены, и
              приоритеты могут быть переопределены по мере необходимости.</ul>
            <ul>Внесение изменений:

              Scrum: Внесение изменений в требования на протяжении спринта не рекомендуется, чтобы не нарушать его
              стабильность.
              Kanban: Внесение изменений происходит непрерывно, и новые задачи могут быть добавлены или изменены в любое
              время.</ul>
          </div>
        </div>

        <div class="nested-block">Документация (Проектная / продуктная)
          <div class="nested-content">
            <p>Продуктная документация (product documentation, development documention52) используется проектной
              командой во время разработки и поддержки
              продукта. Она включает</p>
            <ul>План проекта (project management plan53) и в том числе тестовый план
              (test plan54).</ul>
            <ul>Требования к программному продукту (product requirements document,
              PRD55) и функциональные спецификации</ul>
            <ul>Архитектуру и дизайн</ul>
            <ul>Тест-кейсы и наборы тест-кейсов</ul>
            <ul>Технические спецификации (technical specifications62), такие как схемы
              баз данных, описания алгоритмов, интерфейсов и т.д</ul>
            <p>Проектная документация включает продуктную и: </p>
            <ul>Пользовательскую и сопроводительную документацию (user and accompanying documentation64), такую как
              встроенная помощь, руководство по установке и использованию, лицензионные соглаше</ul>
            <ul>Маркетинговую документацию (market requirements document, MRD65),
              которую представители разработчика или заказчика используют как на
              начальных этапах (для уточнения сути и концепции проекта), так и на
              финальных этапах развития проекта (для продвижения продукта на
              рынке).
            </ul>
          </div>
        </div>   

      </div>
    </div>

    <div class="block"> ТРЕБОВАНИЯ: уровни, типы, свойства, техники
      <div class="content">

        <div class="nested-block">требование
          <div class="nested-content">
            <p>Требование (requirement49) — описание того, какие функции и с соблюдением каких условий должно выполнять
              приложение в процессе решения
              полезной для пользователя задачи</p>
            <ul>Позволяют понять, что и с соблюдением каких условий система должна делать.</ul>
            <ul>Предоставляют возможность оценить масштаб изменений и управлять изменениями</ul>
            <ul>Являются основой для формирования плана проекта (в том числе плана тестировани</ul>
            <ul>Помогают предотвращать или разрешать конфликтные ситуации</ul>
            <ul>Упрощают расстановку приоритетов в наборе задач</ul>
            <ul>Позволяют объективно оценить степень прогресса в разработке проекта.</ul>
          </div>
        </div>

        <div class="nested-block"> Уровни и типы требований
          <div class="nested-content">
            <ul>Бизнес-требования (business requirements69) выражают цель, ради которой
              разрабатывается продук</ul>
            <ul>Пользовательские требования (user requirements71) описывают задачи, которые пользователь может выполнять
            </ul>
            <ul>Функциональные требования (functional requirements78) описывают поведение системы, т.е. её действия
              (вычисления, преобразования, проверки, обработку
              и т.д.) </ul>
            <ul>Нефункциональные требования (non-functional requirements79) описывают
              свойства системы (удобство использования, безопасность, надёжность, расширяемость и т.д.), к</ul>
          </div>
        </div>

        <div class="nested-block"> . Свойства качественных требований
          <div class="nested-content">
            <p>Завершённость - вся инфа</p>
            <p>Атомарность, единичность - нельзя разбить на несколько</p>
            <p>Непротиворечивость, последовательность - </p>
            <p>Недвусмысленность (больших объемов данных - больших? насколько?)</p>
            <p>Выполнимость</p>
            <p>Обязательность, нужность,  актуальность</p>
            <p>Прослеживаемость (пронумерованы, структурированы)</p>
            <p>Модифицируемость (простоту внесения изменений)</p>
            <p>Проранжированность по важности, стабильности, срочности</p>
            <p>Корректность (correctness101) и проверяемость</p>
          </div>
        </div>

        <div class="nested-block">Техники тестирования требований
          <div class="nested-content">
            <p>Взаимный просмотр (рецензирование)</p>
            <p>Вопросы</p>
            <p>Нет возможности составить тест кейс</p>
            <p>Исследование поведения системы (тестировщик продумывает тестирование по требованиям)</p>
            <p>Графическое представление того, к чему требования</p>
            <p>Прототипирование (сделать демо фичи)</p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Виды тестирования, техники тест дизайна
      <div class="content">

        <div class="nested-block">Testing, QC, QA
          <div class="nested-content">
            <ul>Тестирование - соответвие ПО требованиям</ul>
            <ul></ul>
            <ul>quality assurance - охватывает весь цикл
              разработки ПО и затрагивает процессы планирования, проектирования, создания и выполнения
              тест-кейсов</ul>
          </div>
        </div>

        <div class="nested-block">классификация тестирования
          <div class="nested-content">

            <p>По запуску кода на исполнение</p>
            <ul>Статическое  — тестирование без запуска кода на исполнение.
              Документы, графические прототипы, код приложения, среда выполнения, тестовые данные
            </ul>
            <ul>Динамическое - запуск всего или части приложения</ul>

            <p>По степени автоматизации</p>
            <ul>Ручное</ul>
            <ul>Автоматизированное</ul>

            <p>По доступу к коду:</p>
            <ul>Метод белого ящика — доступ к коду есть.</ul>
            <ul>Метод чёрного ящика — доступа к коду нет</ul>
            <ul> Метод серого ящика — к части кода доступ есть, к части — нет</ul>

            <p>По уровню детализации приложения (по уровню тестирования):</p>
            <ul>Модульное (юнит) тестирование — проверяются отдельные
              небольшие части приложения.</ul>
            <ul> Интеграционное тестирование — проверяется взаимодействие между
              несколькими частями приложения.</ul>
            <ul>Системное тестирование — приложение проверяется как единое целое.</ul>

            <p>По степени важности тестируемых функций (по убыванию):</p>
            <ul>Smoke - проверка самой важной, самой ключевой
              функциональности</ul>
            <ul>проверка функциональности, используемой типичными пользователями в типичной повседневной деятельности
            </ul>
            <ul>Расширенное тестирование — проверка всей (остальной) функциональности, заявленной в требовани</ul>

            <p>По принципам работы с приложением</p>
            <ul>Позитивное тестирование — все действия с приложением выполняются строго по инструкции без никаких
              недопустимых действий, некорректных данных и т.д</ul>
            <ul>Негативное тестирование — в работе с приложением выполняются
              (некорректные) операции и используются данные, потенциально приводящие к ошибкам (классика жанра — деление
              на ноль)</ul>

            <p>По уровню выполнения (Execution Level):</p>
            <ul>Unit тесты: Тестирование отдельных компонентов или модулей программы</ul>
            <ul>Integration тесты: Тестирование взаимодействия между различными компонентами </ul>
            <ul>System тесты: Проверка всей системы или приложения в целом для подтверждения соответствия требованиям и
              спецификациям.</ul>


            <p>По характеру работы (Testing Nature):</p>
            <ul>Функциональные тесты: Проверка функциональности системы, чтобы убедиться, что она выполняет ожидаемые
              задачи и дает правильные результаты.</ul>
            <ul>Нефункциональные тесты: Тестирование аспектов, не связанных с функциональностью, таких как
              производительность, надежность, безопасность и т.д.</ul>

            <p>По покрытию:</p>
            <p>По глубине</p>
            <ul>Smoke - основная функциональность на валидных </ul>
            <ul>MAT - minimum acceptance test (проверка каждой функции системы на валидных данных)</ul>
            <ul>AT - acceptance test (+негативные) </ul>
            <p>По ширине</p>
            <ul>NFT - new feature test</ul>
            <ul>DV deffect validation (проверка фичи после исправления деввекта)</ul>
            <ul>Regression</ul>

          </div>
        </div>

        <div class="nested-block">Техники тест дизайна
          <div class="nested-content">
            <p>1 Boundary Value Analysis (BVA):</p>
            <p> Тестирование граничных значений включает проверку минимальных и максимальных значений, а также значений,
              которые находятся на границе между допустимыми классами.
              Таким образом, если параметр имеет диапазон от 1 до 100, то для BVA следует проверить значения 1, 2, 99 и
              100.</p>

            <p>2 Equivalence Partitioning (EP):</p>
            <p>предполагает разделение входных данных на классы эквивалентности, где каждый класс должен быть обработан
              одинаково системой.</p>
            <p>Если тестовый случай из одного класса проходит успешно, то ожидается, что все тестовые случаи из этого
              класса также пройдут успешно. Это позволяет уменьшить количество тестовых случаев при сохранении покрытия.
            </p>
            <p>поле для ввода - 2 класса - валидные и невалидные</p>

            <p>3 Pairwise Testing (Combinatorial Testing):</p>
            <p> используется для минимизации количества тестовых случаев, при этом покрывая все возможные комбинации
              параметров. Техника использует комбинации только двух параметров за раз, так как большинство дефектов
              обнаруживаются при взаимодействии двух параметров.
              например оплатапремиум и обычного акка, visa и mastercart </p>

            <p>4 Decision Table Testing (Cause-Effect Graphing):</p>
            <p>Таблицы причин и следствий создаются для представления всех возможных вариантов входных данных и
              соответствующих ожидаемых результатов</p>
            <p>       | чекбокс 1| правило 2</p>
            <p>поле А |          |          |</p>
            <p>поле B |          |          |</p>
            <p>поле C |          |          |</p>
            <p>Итого получается 9 вариантов</p>

            <p>State Transition Testing:</p>
            <p>это методика тестирования, основанная на исследовании переходов между различными состояниями системы. </p>
            <p>Например светофор (переход от красного до зереного)</p>
            <p>Например переход состояния деффекта в джире</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">TestRail, Тест-кейс и его жизненный цикл, Чек-лист
      <div class="content">

        <div class="nested-block">Тест, тест кейс
          <div class="nested-content">
            <p>Тест — набор из одного или нескольких тест-кейсов.</p>
            <p>Тест-кейс  — набор данных, условий выполнения и
              ожидаемых результатов, цель - проверка свойства или поведения ПО.</p>
            <p>Спецификация тест-кейса — документ, описывающий набор тест-кейсов
              (включая их цели, входные данные, условия и шаги выполнения, ожидаемые результаты) для тестируемого
              элемента</p>
          </div>
        </div>

        <div class="nested-block">Атрибуты (поля) тест-кейс TestRail
          <div class="nested-content">
            <p>Title</p>
            <p>Идентификатор</p>
            <p>Type (тип): , functionality, performance, regression , usability...</p>
            <p>Приоритет</p>
            <p>Estimate (оценка) содержит оценку времени, которое необходимо затратить
              на выполнение тест-кейса.</p>
            <p>References (ссылки) позволяет хранить ссылки на такие артефакты, как требования, пользовательские
              истории, отчёты о дефектах и иные документы
              (требует дополнительной настройки).</p>
            <p>Preconditions (приготовления) </p>
            <p>Step Description (описание шага) позволяет добавлять описание отдельного
              шага тест-кейса. </p>
            <p>Expected Results (ожидаемые результаты) позволяет описать ожидаемый результат по каждому шагу
            </p>
          </div>
        </div>

        <div class="nested-block">Свойства качественных тест-кейсов
          <div class="nested-content">
            <p>технический язык, точность и единообразие формулировок</p>
            <p>Баланс между специфичностью и общностью (чем больше деталей тем более специфичен)</p>
            <p>Баланс между простотой и сложностью</p>
            <p>«Показательность - высокая вероятность обнаружения ошибки)</p>
            <p>Последовательность и Отсутствие лишних действий</p>
            <p>Неизбыточность - 2 теста не должны проверять одно и то же</p>
            <p>Демонстративность- любое отклонение от ожидаемых результатов сразу же бросалось в глаза и</p>
            <p>Прослеживаемость - какую часть приложения, какие функции и какие требования он проверяет</p>
            <p>Возможность повторного использования.</p>
            <p>Повторяемость - при многократном повторении он показывал одинаковые результаты</p>
            <p></p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Плохой тест кейс, чек-лист
          <div class="nested-content">
            <p>Отсутствие заглавия тест-кейса или плохо написанное заглавие</p>
            <p>Отсутствие нумерации шагов и/или ожидаемых результатов</p>
            <p>Ссылка на множество требований</p>
            <p>Использование личной формы глаголов. пишите «нажать» вместо «нажмите»</p>
            <p>Использование прошедшего или будущего времени в ожидаемых результатах</p>
            <p>Постоянное использование слов «проверить» (и ему подобных) в чеклистах</p>
            <p>Описание стандартных элементов интерфейса вместо использования
              их устоявшихся названий («быстро-быстро дважды нажать на левую клавишу мыши)</p>
            <p>Ссылка на другие тест-кейсы или шаги других тест-кейсов</p>
            <p>Расплывчатые двусмысленные описания действий и ожидаемых результатов</p>
            <p>Отсутствие престепов, если они необходимы</p>
            <p>Слишком длинный перечень шагов, не относящихся к сути (цели) тесткейса</p>
            <p>Некорректное наименование элементов интерфейса или их свойств</p>
            <p>Шаг который приводит к крашу приложение(даже в негативном недопустимо)</p>
            <p>Формальные и/или субъективные проверки (Должно работать быстро», много, часто)</p>
          </div>
        </div>

        <div class="nested-block">Чек лист
          <div class="nested-content">
            <p>набор идей, список всех возможных проверок</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Jira, дефект, аттрибуты, жц, отчет
      <div class="content">

        <div class="nested-block">Дефект, Ожидаемый результат, Фактический результат
          <div class="nested-content">
            <p>Дефект — расхождение ожидаемого и фактического результата.</p>
            <p> Ожидаемый результат — поведение системы, описанное в требованиях.</p>
            <p>Фактический результат — поведение системы, наблюдаемое в процессе
              тестирования.</p>
          </div>
        </div>

        <div class="nested-block">атрибуты (поля) деффекта
          <div class="nested-content">
            <ul>priority - влияние деффекта на бизнес</ul>
            <ul>assignee</ul>
            <ul>reporter</ul>
            <ul>status:
              <ul>open</ul>
              <ul>in progress</ul>
              <ul>resolved</ul>
              <ul> closed</ul>
              <ul>postponed (отложен)</ul>
              <ul>resolution (разраб ставит):
                <ul>fixed</ul>
                <ul>fixed inderectly</ul>
                <ul>won't fix</ul>
                <ul>duplicate</ul>
                <ul>incomplete</ul>
                <ul>can not</ul>
              </ul>
              <ul>fix version</ul>

          </div>
        </div>

        <div class="nested-block">Отчёт о дефекте и его жизненный цикл
          <div class="nested-content">
            <p>Отчёт о дефекте (defect report317) — документ, описывающий и приоритизирующий обнаруженный дефект, а
              также содействующий его устранению.</p>
            <ul>Обнаружен (submitted)
              <ul>Назначен (assigned)</ul>
              <ul>Исправлен (fixed) </ul>
              <ul>Проверен (verified)</ul>
              <ul>Закрыт (closed)</ul>
            <ul>Открыт заново (reopened)</ul>
            <ul>Рекомендован к отклонению (to be declined)</ul>
            <ul>Отклонён (declined)</ul>
            <ul>Отложен (deferred)</ul>
          </div>
        </div>

        <div class="nested-block">Из чего состоит отчет о деффекте
          <div class="nested-content">
            <ul>project</ul>
            <ul>issue type (bug, deffect)</ul>
            <ul>summary (краткое описание): где? что? когда?</ul>
            <ul>severity (критичность): crit, major, minor</ul>
            <ul>affect version</ul>
            <ul>enviroment</ul>
            <ul>description</ul>
            <ul>attachment</ul>
            <ul>expected result</ul>
          </div>
        </div>

        <div class="nested-block">Свойства качественных отчётов о дефектах
          <div class="nested-content">
            <ul>Тщательное заполнение всех полей точной и корректной информацией</ul>
            <ul>Правильный технический язык</ul>
            <ul>Специфичность описания шагов (Детальное описание)</ul>
            <ul>Отсутствие лишних действий и/или их длинных описаний.</ul>
            <ul>Прослеживаемость. Из содержащейся в качественном отчёте о дефекте информации должно быть понятно, какую часть приложения, какие функции и какие
              требования затрагивает дефект</ul>
            <ul>Отдельные отчёты для каждого нового дефекта</ul>
            <ul>Отсутствие дубликатов.</ul>
            <ul>Очевидность и понятность</ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Тест-план и отчёт о результатах тестирования
      <div class="content">

        <div class="nested-block">Тест план
          <div class="nested-content">
            <p>Тест-план (test plan329) — документ, описывающий и регламентирующий
              перечень работ по тестированию, а также соответствующие техники и подходы, стратегию, области
              ответственности, ресурсы, расписание и ключевые даты.</p>
            <ul>Цель (purpose)</ul>
            <ul>Области, подвергаемые тестированию</ul>
            <ul>Области, не подвергаемые тестированию</ul>
            <ul>Тестовая стратегия (test strategy330) и подходы (test approach331). Описание
              процесса тестирования с точки зрения применяемых методов, подходов, видов тестирования, технологий,
              инструментальных средств и т.д.</ul>

            <ul>Критерии:
              <ul>Приёмочные критерии, критерии качества (acceptance criteria332) —
                любые объективные показатели качества, которым разрабатываемый
                продукт должен соответствовать с точки зрения заказчика или пользователя, чтобы считаться готовым к
                эксплуатац</ul>
              <ul>Критерии начала тестирования (entry criteria333) — перечень условий,
                при выполнении которых команда приступает к тестированию. Наличие этого критерия страхует команду от
                бессмысленной траты усилий
                в условиях, когда тестирование не принесёт ожидаемой пользы</ul>
              <ul>Критерии приостановки тестирования (suspension criteria334) — перечень условий, при выполнении которых
                тестирование приостанавливается. Наличие эт</ul>
              <ul>Критерии возобновления тестирования</ul>
              <ul> Критерии завершения тестирования</ul>
            </ul>

            <ul>Ресурсы (resources): программы, человеческие ресурсы, временные, финансовые</ul>
            <ul>Расписание</ul>
            <ul>Роли и ответственность</ul>
            <ul>Оценка рисков</ul>
            <ul>Документация</ul>
            <ul>Метрики (metrics338). Числовые характеристики показателей качества, способы их оценки, формулы и т.д.
            </ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">mock, stub, этапы тестирования, валидация \ верификация

      <div class="content">

        <div class="nested-block">виды тестовых объектов?
          <div class="nested-content">
            <p>пустышка (dummy) - объект, который обычно передается в тестируемый класс в качестве параметра,
              но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.</p>
            <p>фальшивка (fake object) применяется в основном для ускорения запуска ресурсоёмких тестов и является
              заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.</p>
            <p>заглушка (test stub) используется для получения данных из внешней зависимости, подменяя её.
              При этом заглушка игнорирует все данные, поступающие из тестируемого объекта, возвращая заранее
              определённый результат.</p>
            <p>шпион (test spy) - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из
              тестируемой системы,
              чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание
              параметров вызовов.</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Чем stub отличается от mock?
          <div class="nested-content">
            <p>stub используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на
              вызовы.</p>
            <p>mock использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и
              контролирует его.</p>
          </div>
        </div>

        <div class="nested-block">основные этапы тестирования ПО
          <div class="nested-content">
            <p>Работа с требованиями. Обсуждение с заказчиком требований к продукту для выявления противоречий и
              потенциальных проблем в работе программ</p>
            <p>Разработка стратегии тестирования и планирование процедур контроля качества. Руководитель команды
              составляет план тестирования: какие виды и инструменты будут применяться в проекте, в какие сроки оно
              должно быть выполнено, с чего оно начнётся и чем закончится</p>
            <p>Создание тестовой документации. На основе стратегии тестирования составляют документы: тест-план,
              тест-кейсы и чек-листы. Задача этого этапа — детально описать, что и как нужно тестировать.</p>
            <p>Основное тестирование. Ключевой этап всего процесса — программу тестируют по заранее написанным сценариям
              и выявляют ошибки, на основе которых составляют подробные отчёты.</p>
            <p>Стабилизация. Разработчики устраняют найденные ошибки, после чего проводится повторное или
              регресс-тестирование — оно помогает понять, как программа ведёт себя с учётом изменений.</p>
            <p>Эксплуатация и поддержка. Так как часто ошибки обнаруживаются уже после релиза, тестировщики продолжают
              работать с программой и на этом этапе — например, чтобы собрать обратную связь от пользователей.</p>
          </div>
        </div>

        <div class="nested-block">Чем валидация отличается от верификации?
          <div class="nested-content">
            <p>Верификация — это проверка системы на соответствие условиям, которые были определены в начале разработки.
            </p>
            <p>Валидация — это оценка соответствия работы программы ожиданиям пользователя.</p>
          </div>
        </div>

        <div class="nested-block">Что такое тест-план и зачем он нужен?
          <div class="nested-content">
            <p>Тест-план — это документ, который поэтапно описывает весь процесс тестирования, начиная от целей и сроков
              и заканчивая обязанностями каждого члена команды.</p>
          </div>
        </div>

        <div class="nested-block">Чем тест-кейс отличается от чек-листа?
          <div class="nested-content">
            <p>Чек-лист — это список того, что нужно проверить. Например, можно составить чек-лист для проверки сайта
              или отдельного его компонента — скажем, личного кабинета или корзины.</p>
            <p>Тест-кейс — это пошаговое описание того, как мы будем тестировать ту или функцию.</p>
          </div>
        </div>


      </div>
    </div>

  </div>

  <div id="block-3" class="block content">
    <div class="block">Шаблоны для тестирования
      <div class="content">

        <div class="nested-block">Page Object паттерн
          <div class="nested-content">
            <p>позволяет организовать и структурировать код автотестов.
              абстрагировать каждую страницу веб-приложения в отдельный класс, который предоставляет методы для
              взаимодействия
              с элементами на этой странице.
              Это помогает разделить логику тестов от логики работы с пользовательским интерфейсом, упрощая тестирование
              и поддержку </p>
            <p>Класс страницы (Page Class):</p>
            <ul>Каждая страница веб-приложения представляется в виде отдельного класса.</ul>
            <ul>Класс содержит локаторы элементов (XPath, CSS, ID и т.д.), которые идентифицируют элементы на странице.
            </ul>
            <ul>Класс также содержит методы для взаимодействия с элементами, такие как клики, ввод текста, получение
              текста и т.д.</ul>
            <p>(Step Class)</p>
            <ul>Как правило, в тестовом классе выполняются только вызовы методов из Steps классов, которые, в свою
              очередь, взаимодействуют с Page Object классами.</ul>
            <p>Тестовый класс (Test Class)</p>
          </div>
        </div>

        <div class="nested-block">Test-driven development (TDD)
          <div class="nested-content">
            <p>Способ разработки ПО, когда тест кейсы разрабатываются и зачастую автоматизируются до разработки самого
              ПО</p>
          </div>
        </div>

        <div class="nested-block">Data-Driven Testing (DDT)
          <div class="nested-content">
            <p> это паттерн тестирования, который позволяет проводить тесты с использованием различных наборов данных.
              Вместо того чтобы зашивать данные напрямую в тестовый код, в DDT данные разделяются от логики теста.</p>
            <p>Основные компоненты</p>
            <ul>Тестовый сценарий: Это код теста, который выполняет определенные проверки или действия на основе данных
            </ul>
            <ul>Входные данные (Data Sets): Наборы данных, которые используются для запуска тестов с различными
              значениями.
              Эти данные могут быть представлены в виде таблицы, файла Excel, базы данных и т.д.</ul>
          </div>
        </div>

        <div class="nested-block">Behavior-Driven Development (BDD)
          <div class="nested-content">
            <p>это методология разработки программного обеспечения, которая ставит в центр внимания поведение
              (поведенческие аспекты) системы и позволяет лучше связать бизнес-аналитиков, разработчиков и тестировщиков
              в процессе разработки.</p>
            <p>Основные принципы BDD</p>
            <ul>Язык описания поведения: BDD способствует использованию общего и понятного языка описания поведения
              системы, который доступен и понятен всем участникам разработки</ul>
            <ul>Сценарии поведения: В BDD системное поведение описывается с помощью сценариев, представленных в виде
              "Шагов" (Steps) с языковым выражением Gherkin (Given-When-Then). Это позволяет легко понять, что ожидается
              от системы в определенных ситуациях.</ul>
            <ul>Общая понятность и Тесное взаимодействие между командами: Основной идеей BDD является создание общего
              понимания между всеми участниками разработки,</ul>

            <p>Ключевые элементы BDD:</p>
            <ul>Шаги (Steps): Шаги представляют собой действия или состояния системы в языке Gherkin: Given (Учитывая),
              When (Когда) и Then (Тогда). Они представляют сценарии поведения системы.</ul>
            <ul>Фича (Feature): Фича представляет собой файл сценария на языке Gherkin, описывающий функциональность или
              особенность системы.</ul>
            <ul>Сценарий (Scenario): Сценарий представляет собой конкретный тестовый сценарий, описанный с
              использованием Шагов. Каждый сценарий обычно содержит предусловия (Given), действия (When) и ожидаемые
              результаты (Then)</ul>
          </div>
        </div>

        <div class="nested-block">Keyword-Driven Testing (KDT)
          <div class="nested-content">
            <p>это методология, разделяет тестовые сценарии и наборы действий (ключевые слова).
              В KDT тесты представлены в виде наборов ключевых слов и аргументов, которые обозначают действия и
              проверки,
              выполняемые в процессе тестирования. </p>
            <ul>Предположим, у нас есть тестирование функции сложения двух чисел. Мы можем определить следующие ключевые
              слова:</ul>
            <ul>Open Browser: Открывает браузер.</ul>
            <ul>Navigate To: Переходит на указанный URL.</ul>
            <ul>Enter Number: Вводит число в указанное поле.</ul>
            <ul>Click Add Button: Нажимает кнопку "Сложить".</ul>
            <ul>Verify Result: Проверяет результат сложения на странице.</ul>
          </div>
        </div>

        <div class="nested-block">Singleton
          <div class="nested-content">
            <p>паттерн проектирования, который гарантирует, что у класса есть только один единственный экземпляр, и
              предоставляет глобальную точку доступа к этому экземпляру.</p>
            <ul>Приватный конструктор:</ul>
            <ul>Статическое поле экземпляра: Класс Singleton содержит статическое поле, которое хранит единственный
              экземпляр объекта</ul>
            <ul>Статический метод для доступа: Класс Singleton предоставляет статический метод, который возвращает
              единственный экземпляр класса. Этот метод обычно называется getInstance().</ul>
            <ul>Ленивая инициализация: Объект Singleton создается только при первом вызове метода getInstance()</ul>
          </div>
        </div>

        <div class="nested-block">Factory Method (Фабричный метод)
          <div class="nested-content">
            <p>Он предоставляет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип
              создаваемых объектов. </p>
            <p>Пример: у нас есть две роли - администратор и обычный пользователь.</p>
            <p>interface AuthenticationStrategy {</p>
            <p>void login(String username, String password);}</p>


            <p>class AdminAuthenticationStrategy implements AuthenticationStrategy {</p>
            <p>public void login(String username, String password) {...}</p>

            <p>class UserAuthenticationStrategy implements AuthenticationStrategy {</p>
            <p>public void login(String username, String password) {...}</p>

            <p>abstract class AuthenticationStrategyFactory {</p>
            <p>public abstract AuthenticationStrategy createAuthenticationStrategy();}</p>

            <p>class AdminAuthenticationStrategyFactory extends AuthenticationStrategyFactory {</p>
            <p>public AuthenticationStrategy createAuthenticationStrategy() {</p>
            <p> return new AdminAuthenticationStrategy();}}</p>

            <p>class UserAuthenticationStrategyFactory extends AuthenticationStrategyFactory {</p>
            <p>public AuthenticationStrategy createAuthenticationStrategy() {</p>
            <p> return new UserAuthenticationStrategy();;}}</p>

            <p>AuthenticationStrategyFactory adminFactory = new AdminAuthenticationStrategyFactory();</p>
            <p>AuthenticationStrategyFactory userFactory = new UserAuthenticationStrategyFactory();</p>

            <p>AuthenticationStrategy adminStrategy = adminFactory.createAuthenticationStrategy();</p>
            <p>AuthenticationStrategy userStrategy = userFactory.createAuthenticationStrategy();</p>

            <p>// Сценарий тестирования авторизации администратора</p>
            <p>adminStrategy.login("admin", "adminPassword");</p>

            <p>// Сценарий тестирования авторизации обычного пользователя</p>
            <p>userStrategy.login("user", "userPassword");</p>

          </div>
        </div>


      </div>
    </div>

    <div class="block">Шаблоны, Patterns

      <div class="content">

        <div class="nested-block">SOLID
          <div class="nested-content">
            <p>Single responsibility — принцип единственной ответственности</p>
            <p>обозначает, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью
              инкапсулирована в класс</p>
            <p>Open-closed — принцип открытости / закрытости</p>
            <p>программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для
              изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
            Например класс -внесен в библиотеку - его не трогать, а расширять наследованием</p>
            <p>Liskov substitution principle / LSP</p>
            <p>объекты базового класса должны быть заменяемыми объектами производного класса без изменения правильности
              выполнения программы. Если класс B является подтипом класса A, то объекты класса A могут быть заменены
              объектами класса B без изменения корректности программы.</p>
            <p>Принцип разделения интерфейса (interface segregation principle / ISP)</p>
            <p>слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, </p>
            <p>Принцип инверсии зависимостей (dependency inversion principle / DIP</p>
            <p>Классы верхних уровней (где бизнес логика) не должны зависеть от классов нижних уровней (где базовые операции).
               Оба должны зависеть от абстракций.</p>
          </div>
        </div>

        <div class="nested-block">Порождающие: Фабричный метод (Factory method)
          <div class="nested-content">
            <p> Делегирует создание объектов наследникам родительского класса. </p>
            <p>Создатель (Creator): Абстрактный класс или интерфейс, который объявляет метод для создания объекта.</p>
            <p>Конкретный Создатель (Concrete Creator): Реализует метод создания объекта, который может быть переопределен в подклассах, чтобы создавать разные типы объектов. </p>
            <p> Продукт (Product): Абстрактный класс или интерфейс, который определяет интерфейс создаваемых объектов.</p>
            <p> Конкретный Продукт (Concrete Product): Реализует интерфейс продукта.</p>
            <img src="images/FactoryMethod.png">
<pre><code>
// Продукт
interface Test {
    void run();
}

// Конкретные продукты
class UnitTest implements Test {
    @Override
    public void run() {
        System.out.println("Running unit test");
    }
}

class IntegrationTest implements Test {
    @Override
    public void run() {
        System.out.println("Running integration test");
    }
}

// Создатель
abstract class TestFactory {
    abstract Test createTest();
}

// Конкретные создатели
class UnitTestFactory extends TestFactory {
    @Override
    Test createTest() {
        return new UnitTest();
    }
}

class IntegrationTestFactory extends TestFactory {
    @Override
    Test createTest() {
        return new IntegrationTest();
    }
}

public class Main {
    public static void main(String[] args) {
        TestFactory unitTestFactory = new UnitTestFactory();
        Test unitTest = unitTestFactory.createTest();
        unitTest.run(); // Вывод: Running unit test

        TestFactory integrationTestFactory = new IntegrationTestFactory();
        Test integrationTest = integrationTestFactory.createTest();
        integrationTest.run(); // Вывод: Running integration test
    }
}
</code></pre>
          </div>
        </div>

        <div class="nested-block">Порождающие: Абстрактная фабрика
          <div class="nested-content">
            <p>Класс, который представляет собой интерфейс для создания других  классов.</p>
            <p>Абстрактная фабрика (Abstract Factory): Определяет интерфейс для создания семейств взаимосвязанных объектов.</p>
            <p>Конкретная фабрика (Concrete Factory): Реализует интерфейс абстрактной фабрики, создавая семейство конкретных объектов.</p>
            <p>Абстрактные продукты (Abstract Products): Определяют интерфейс для различных типов объектов, которые создаются семейством продуктов.</p>
            <p>Конкретные продукты (Concrete Products): Реализуют интерфейс абстрактных продуктов.</p>
            <img src="images/abstractFactory.png">
          </div>
        </div>

        <div class="nested-block">Порождающие: 
          <div class="nested-content">
            <p>Строитель (Builder) - Класс, который представляет собой интерфейс для создания сложного объекта.</p>
            <p>Директор (Director): Определяет порядок шагов и взаимодействует с билдером для создания объекта</p>
            <p>Билдер (Builder): Определяет интерфейс для создания различных частей объекта и метод для получения готового объекта.</p>
            <p>Конкретный билдер (Concrete Builder): Реализует интерфейс билдера, предоставляя методы для создания различных частей объекта и метод для возврата готового объекта</p>
            <p>Продукт (Product): Представляет созданный объект. Включает в себя компоненты, созданные билдером.</p>
            <img src="images/Builder.png">
          </div>
        </div>

        <div class="nested-block">Порождающие: ПРототип
          <div class="nested-content">
            <p>Класс, который может иметь только один экземпляр.</p>
            <p> Прототип (Prototype): Определяет интерфейс клонирования. Может содержать методы для глубокого или поверхностного клонирования.</p>
            <p>Конкретный прототип (Concrete Prototype): Реализует интерфейс прототипа. Реализует метод клонирования.</p>
            <p>Клиент (Client): Создает новые объекты путем клонирования существующих прототипов.</p>
            <p>ПО ФАКТУ: класс объекта (и все классы его расширяющие) реализует метод clone</p>
          </div>
        </div>

        <div class="nested-block">Порождающие: Singleton
          <div class="nested-content">
            <p>Класс, который может иметь только один экземпляр.</p>
            <p>Приватный конструктор, статический метод, который возвращает единственный инстанс</p>
          </div>
        </div>

        <div class="nested-block">Структрный: Адаптер
          <div class="nested-content">
            <p>Адаптер (Adapter) - Объект, обеспечивающий взаимодействие двух других объектов, один из которых
              использует, а другой предоставляет несовместимый с первым интерфейс.</p>
          </div>
        </div>

        <div class="nested-block"> структурные 
          <div class="nested-content">
            <p>Мост (Bridge) — это структурный паттерн проектирования, который
              разделяет один или несколько классов на две отдельные
              иерархии — абстракцию и реализацию, позволяя изменять
              их независимо друг от друга.
            </p>
            <p>позволяет сгруппировать множество объектов в
              древовидную структуру, а затем работать с ней так, как
              будто это единичный объект</p>
              <ul>Компонент (Component): Определяет общий интерфейс для всех компонентов (и объектов, и контейнеров).</ul>
              <ul>Лист (Leaf): Представляет отдельные объекты, не имеющие дочерних компонентов.</ul>
              <ul>Контейнер (Composite): Представляет составные группы объектов. Может содержать как объекты-листья, так и другие контейнер</ul>
            <p>Декоратор (Decorator) - Класс, расширяющий функциональность другого класса без использования
              наследования.</p>
            <p>Фасад (Facade) - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
            </div>
        </div>

        <div class="nested-block">Поведенческие
          <div class="nested-content">
            <p>Цепочка обязанностей (Chain of responsibility) - Предназначен для организации в системе уровней
              ответственности.</p>
            <p>Итератор (Iterator) - Представляет собой объект, позволяющий получить последовательный доступ к элементам
              объекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.</p>
            <p>Наблюдатель (Observer) - Определяет зависимость типа «один ко многим» между объектами таким образом, что
              при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">Алгоритмы

      <div class="content">

        <div class="nested-block">БИНАРНЫЙ ПОИСК  O(log(n))
          <div class="nested-content">
            <p>Задача: Найти число в массиве</p>
            <p>Отсортировываем массив</p>
            <p>Если искомое число больше среднего, то ищем во второй половине массива</p>
            <p>Продолжаес разбивать на половинки и сравнивать со средним</p>
            <img src="images/binarySearch.png">
          </div>
        </div>

        <div class="nested-block">СОРТИРОВКА ВЫБОРОМ O(n*n) 
          <div class="nested-content">
            <p>Задача: Отсортировать массив </p>
            <p>Проходим весь массив, находим наименьшее - добавляем в новый массив</p>
            <p>Удаляем предыдущий и ищем следующиее меньшее</p>
          </div>
        </div>

        <div class="nested-block">БЫСТРАЯ СОРТИРОВКА
          <div class="nested-content">
            <p>Берется первый (опорный) элемент</p>
            <p>Массив разделяется на 2, 1-ый больше, 2-ой меньше опорного</p>
            <p>К каждому массиву применяется тот же алгоритм рекурсивно</p>
          </div>
        </div>


      </div>
    </div>
  </div>

  <div id="block-4" class="block content">
    <div class="block">HTML, TCP IP, DHCP, DNS, Websocket
      <div class="content">

        <div class="nested-block">HTML
          <div class="nested-content">
            <p>HTML, HyperText Markup Language («язык гипертекстовой разметки») — стандартизированный язык разметки
              документов в WWW. На данный момент актуальна 5 версия этого языка - HTML5.</p>
          </div>
        </div>

        <div class="nested-block">уровни модели OSI?
          <div class="nested-content">
            <p>Физический (physical) Биты (bit) Работа со средой передачи, сигналами и двоичными данными USB, витая пара
            </p>
            <p>Канальный (data link) Биты (bit) / Кадры (frame) Физическая адресация Ethernet, IEEE 802.2, L2TP</p>
            <p>Сетевой (network) Пакеты (packet) Определение маршрута и логическая адресация IP, AppleTalk</p>
            <p>Транспортный (transport) Сегменты(segment) / Дейтаграммы(datagram) Прямая связь между конечными пунктами
              и надежность TCP, UDP</p>
            <p>Прикладной (application) - Доступ к сетевым службам HTTP, FTP</p>
          </div>
        </div>

        <div class="nested-block">TCP/IP?
          <div class="nested-content">
            <p>TCP — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки
              соединения между двумя хостами. </p>
            <p>IP (Internet Protocol) - маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию,
              фрагментацию и восстановление пакетов. В его задачу входит продвижение пакета между сетями – от одного
              маршрутизатора до другого и тех пор, пока пакет не попадет в сеть назначения.</p>
            <p>HTTP (80 порт/TCP) и HTTPS (443 порт/TCP) – отличие S в надстройке безопасности (+шифрование) </p>
            <p>Почта: SMTP (25 порт/TCP) – отправка на почтовый сервер </p>
            <p>IMAP (143 порт/TCP) – для авторизации и подключения </p>
            <p>Шифрование трафика – SSH (22 порт/TCP) – SSH-ключ – файл для доступа (к серверу) </p>
          </div>
        </div>

        <div class="nested-block">DHCP
          <div class="nested-content">
            <p>– сетевой протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры,
              необходимые для работы в сети TCP/IP.</p>
          </div>
        </div>

        <div class="nested-block">DNS (Domain Name System)
          <div class="nested-content">
            <p>компьютерная информационная система для получения информации о доменах. Набор серверов, хранящих
              соответствие IP-адреса и домена. </p>
          </div>
        </div>

        <div class="nested-block">Что такое WebSocket?
          <div class="nested-content">
            <p>WebSocket — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями
              между браузером и web-сервером в режиме реального времени.</p>
          </div>
        </div>

        <div class="nested-block">REST
          <div class="nested-content">
            <p>REST (Representational State Transfer) - это архитектурный стиль для разработки распределенных систем, 
              особенно веб-сервисов.  Он представляет собой набор ограничений и рекомендаций, которые описывают, 
              как должны взаимодействовать клиенты и серверы в распределенных средах. 
              Основной концепцией REST является представление ресурсов (например, объектов, данных) 
              через уникальные URL и использование стандартных методов HTTP (GET, POST, PUT, DELETE) для взаимодействия с ними.
            </p>
            <p>RESTful - это термин, который описывает веб-сервисы или архитектурные решения, следующие принципам и ограничениям REST. Если сервис или система соответствует этим принципам, то её можно назвать RESTful.</p>
            <p>Основные принципы REST включают:</p>
            <ul>Клиент-Сервер: Разделение клиента и сервера, что позволяет им развиваться независимо друг от друга.
            </ul>
            <ul>Без состояния (Stateless): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию, чтобы сервер мог понять и выполнить запрос. Состояние клиента не хранится на сервере между запросами.</ul>
            <ul>Кеширование: Серверы могут помечать ответы как кешируемые или некешируемые. Клиенты могут кэшировать ответы, чтобы избежать повторных запросов к серверу.</ul>
            <ul>Единообразие интерфейса: Интерфейс взаимодействия между клиентом и сервером должен быть единообразным. Это включает использование уникальных URL для доступа к ресурсам и стандартных HTTP-методов.</ul>
            <ul>Слои (Layered System): Архитектура может включать в себя промежуточные серверы (прокси, балансировщики нагрузки), которые обеспечивают дополнительные функции.</ul>
          </div>
        </div>

      </div>
    </div>

    <div class="block">API, HTTP, GET, 404, Mocking, SOAP
      <div class="content">

        <div class="nested-block">API, типы
          <div class="nested-content">
            <p>Application Programming Interface) используют его для создания веб-сервисов,
              которые могут обмениваться данными с другими приложениями и сервисами через интернет.
            <p>Типы API</p>
            <ul>
              REST - это набор принципов архитектуры, а RESTful - это API, которое реализует эти Принципы.
              основан на HTTP-протоколе и 
              использует запросы HTTP для обмена данными между клиентом и сервером.
              Для каждого запроса клиент должен указать метод (GET, POST, PUT, DELETE), URL-адрес и параметры запроса.
            </ul>
            <ul>SOAP API (Simple Object Access Protocol API)
              используют его для обмена данными между приложениями, работающими на разных платформах, например, между
              .NET и Java. </ul>
            <ul>GraphQL API  — это относительно новый тип API. используют его для создания гибких и эффективных
              веб-сервисов,
              которые могут быстро и точно получать необходимые данные.
              GraphQL API основан на запросах, которые отправляются клиентом серверу в формате GraphQL.
              Каждый запрос содержит только те данные, которые нужны клиенту, что делает этот тип API более быстрым
              и эффективным, чем другие. </ul>
            <ul>WebSocket API
              WebSocket API — это тип API, который используется для создания постоянного соединения между клиентом
              и сервером.
              Он позволяет клиенту и серверу передавать данные в режиме реального времени,
              без необходимости постоянно отправлять запросы.
              Например, передача видеопотока в видеохостинге или сервисе облачного гейминга. </ul>
          </div>
        </div>

        <div class="nested-block">Структура HTTP запроса
          <div class="nested-content">
            <ul>Стартовая строка (Start Line): Стартовая строка определяет тип запроса,
              URI (Uniform Resource Identifier) и версию HTTP протокола
            например:
            GET /wiki/HTTP HTTP/1.0
            Host: ru.wikipedia.org</ul>
            <ul>Заголовки (Headers): Заголовки содержат дополнительную информацию о запросе,
              такую как тип содержимого (Content-Type), длину контента (Content-Length), аутентификацию и т.д.</ul>
            <ul>Тело (Body): Тело запроса содержит данные, которые могут передаваться на сервер. </ul>
          </div>
        </div>

        <div class="nested-block">Аутентификация / авторизация
          <div class="nested-content">
            <p>Аутентификация - это процесс проверки подлинности пользователя или приложения
              Наиболее распространенные методы аутентификации включают OAuth, JWT (JSON Web Token) и API ключи
            </p>
            <p>JWT - это стандарт для представления информации между двумя сторонами в виде JSON объекта.</p>
            <p>Авторизация (Authorization) определяет, какие действия и ресурсы может выполнять или получать
              аутентифицированный пользователь</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">КОДЫ
          <div class="nested-content">
            <p>1xx (Informational): Информационные, запрос получен и сервер продолжает обработку.</p>
            <p>200 OK: успешное выполнение запроса и возврат данных клиенту.</p>
            <p>201 Created: успешное создание нового ресурса в результате POST запроса.</p>
            <p>204 No Content:успешно , но в ответе нет содержимого, например, при успешном удалении ресурса.</p>

            <p>3xx (Redirection):</p>
            <p>4xx (Client Errors):</p>

            <p>400 Bad Request:некорректный запрос, и сервер не может обработать.</p>
            <p>401 Unauthorized: клиент должен предоставить аутентификацию для получения доступа к запрашиваемому
              ресурсу.</p>
            <p>403 Forbidden: Клиент прошел аутентификацию, но не имеет разрешения для доступа к запрашиваемому ресурсу.
            </p>
            <p>404 Not Found: Запрашиваемый ресурс не найден на сервере.</p>
            <p>405 Method Not Allowed: Клиент использовал метод, который не разрешен для запрашиваемого ресурса.</p>

            <p>5xx (Server Errors):</p>
            <p>500 Internal Server Error: Общий код ошибки, который указывает на ошибку на стороне сервера, когда
              обработка запроса не удалась.</p>
            <p>502 Bad Gateway: Ошибка на стороне промежуточного сервера или шлюза при попытке получить ответ от другого
              сервера.</p>
            <p>503 Service Unavailable: Сервер временно недоступен из-за перегрузки или обслуживания.</p>
            <p>504 Gateway Timeout: Время ожидания истекло для запроса, направленного на промежуточный сервер или шлюз.
            </p>
          </div>
        </div>

        <div class="nested-block"> Swagger/OpenAPI
          <div class="nested-content">
            <p>: Swagger/OpenAPI - это инструменты для создания, документирования и тестирования RESTful API. Они
              предоставляют стандартизированный способ описания структуры и функциональности API.</p>
          </div>
        </div>

        <div class="nested-block">Mocking
          <div class="nested-content">
            <p>Мокирование (Mocking) - это техника в программировании и тестировании, которая заключается в создании
              "поддельных"
              или "заглушечных" объектов, которые эмулируют поведение реальных объектов в контролируемой среде.</p>
            <p>мокирование позволяет изолировать API от внешних сервисов, баз данных или других внешних ресурсов, чтобы
              тестировать его функциональность независимо от этих зависимостей. Вместо реальных запросов к внешним
              ресурсам,
              в тестах используются моки (mocks), которые эмулируют ответы, которые были бы получены от реального
              сервиса.</p>
            <ul>Тестирование без реальных сервисов: Мокирование позволяет проводить тестирование API даже в том случае,
              если реальные сервисы или ресурсы недоступны, не готовы или еще не реализованы.</ul>
            <ul>Контроль над данными и ответами: С использованием мокирования можно точно определить, какие данные и
              какие ответы должны быть получены из моков. </ul>
            <ul>Сокращение времени выполнения тестов: Запросы к реальным сервисам могут занимать время, что может
              замедлить выполнение тестов.</ul>
            <ul>Изоляция от внешних изменений: Используя моки, можно избежать проблем, связанных с изменениями во
              внешних сервисах или ресурсах, которые могут повлиять на результаты тестирования.</ul>
            <ul>Проверка обработки ошибок: Мокирование позволяет создать сценарии, когда внешний сервис возвращает
              ошибку или некорректные данные</ul>
            <ul>Тестирование на ранних этапах разработки: Мокирование позволяет тестировать API даже на ранних этапах
              разработки, когда реальные сервисы еще не готовы или изменяются.</ul>
          </div>
        </div>

        <div class="nested-block">SOAP (Simple Object Access Protocol)
          <div class="nested-content">
            <p>то протокол обмена сообщениями в формате XML удаленными системами, работающими на различных платформах и
              языках программирования</p>
            <p>Структура сообщения SOAP:</p>
            <ul>Envelope («конверт»). Это корневой элемент. Определяет XML-документ как сообщение SOAP с помощью
              пространства имен</ul>
            <ul>Заголовок (Header): Опциональная часть сообщения, которая содержит дополнительные метаданные или
              информацию о безопасности и маршрутизации сообщения.</ul>
            <ul>Тело (Body): Обязательная часть сообщения, которая содержит данные, которые требуется передать между
              отправителем и получателем.</ul>
            <ul>Fault (Ошибка): Опциональная часть сообщения, которая используется для передачи информации об ошибках и
              исключительных ситуациях.</ul>

          </div>
        </div>


        <div class="nested-block">Get Post Put Patch
          <div class="nested-content">
            <p>Get - запрашивает - индепотентный</p>
            <p>HEAD - запрашивает - индепотентный в ответе сервера отсутствует тело. бычно применяется для извлечения метаданных, проверки наличия ресурса</p>
            <p>POst - создает новый ресурс из данных</p>
            <p>Put заменяет - индепотентный 
              Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус 201 (Created). 
              Если же ресурс был изменён, то сервер возвращает 200 (Ok) или 204 (No Content)
            </p>
            <p>Patch - обновляет</p>
            <p>GET передает данные серверу, используя URL, тогда как POST передает данные, используя тело HTTP запроса.
              Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать
              через GET. POST может отправлять гораздо большие объемы данных. Лимит устанавливается web-server и
              составляет обычно около 2 Mb.

              Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль)
              не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. Иногда
              это преимущество превращается в недостаток - вы не сможете послать данные за кого-то другого.</p>
          </div>
        </div>

        <div class="nested-block">A
          <div class="nested-content">
            <p>B</p>
          </div>
        </div>





      </div>
    </div>
  </div> 

  <div id="block-5" class="block content">

    <div class="block">mySQL

      <div class="content">

        <div class="nested-block">ПОНЯТИЯ ТАБЛИЦЫ SQL
          <div class="nested-content">
            <img src="images/sqlTable.png" alt="Описание изображения">
            <p>отношение  – это структура данных целиком, набор записей</p>
            <p>кортеж – это каждая строка , содержащая данные</p>
            <p>мощность – число кортежей в таблице</p>
            <p>атрибут – это столбец в таблице (поле, столбец)</p>
            <p>размерность – это число атрибутов (полей, столбцов)</p>
            <p>домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле</p>
          </div>
        </div>

        <div class="nested-block">ТИПЫ ДАННЫХ (INT, VARCHAR...)
          <div class="nested-content">
            <p>INTEGER (INT) TINYINT, SMALLINT, MEDIUMINT, INT и BIGINT</p>
            <p>FLOAT и DOUBLE</p>
            <p> CHAR(10) хранит 10 символов, VARCHAR(255) для хранения строк переменной длины с максимальной длиной 255</p>
            <p>DATE:  даты в формате 'YYYY-MM-DD</p>
            <p>TIME:  времени в формате 'HH:MM:SS'.</p>
            <p>DATETIME и TIMESTAMP: DATETIME хранит дату и время в формате 'YYYY-MM-DD HH:MM:SS'. 
              TIMESTAMP также хранит дату и время, но с ограничением от 1970-01-01 00:00:01 UTC до 2038-01-19 03:14:07 UTC.</p>
            <p>BOOLEAN (BOOL): Этот тип данных используется для хранения булевых значений. В MySQL TRUE представляется как 1, а FALSE как 0</p>
            <p>BLOB для хранения двоичных данных, таких как изображения, аудио или видео. TINYBLOB, BLOB, MEDIUMBLOB и LONGBLOB.</p>
            <p>ENUM: ENUM - это перечислимый тип данных, который позволяет выбрать одно значение из ограниченного набора значений, которые вы определяете при создании столбца.</p>
            <p>SET: SET похож на ENUM, но позволяет выбрать несколько значений из заданного набора.</p>
            <p>JSON: Тип данных JSON позволяет хранить данные в формате JSON.</p>
            <p>GEOMETRY: Тип данных GEOMETRY предназначен для хранения географических данных, таких как координаты точек, линий и полигонов.</p>
            <p>TEXT: Тип данных TEXT предназначен для хранения текстовых данных переменной длины.</p>
            <p></p>
            <p></p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">CREATE DATABASE, USE, CREATE TABLE, INSERT
          <div class="nested-content">
            <p>ДЛя начала работы с БД, нужно создать и выбрать бд</p>
            <p>CREATE DATABASE database_name</p>
            <p>USE database_name</p>
            <p>создание таблицы</p>
<pre><code>
  CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8, 2),
    amount INT
  );
  </code></pre>
            <p>Вставка в таблицу</p>
  <pre><code>
  INSERT INTO book (title, author, price, amount) 
  VALUES ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);
  </code></pre>
          </div>
        </div>


        <div class="nested-block">ОПЕРАТОРЫ BETWEEN, IN, AND, OR, NOT, ROUND, AS
          <div class="nested-content">
            <p>округлить price (скидка 30%) и дать новое название new_price</p>
<pre><code>
SELECT title, author, amount, ROUND( (price - price * 0.3), 2) AS new_price
from book;
</code></pre>
            <p>условия где price ОТ и ДО, amount какое-то значение из списка</p>
<pre><code>
SELECT title, author FROM book
WHERE (price >= 540.50 AND price <= 800) AND amount IN (2, 3, 5, 7);
</code></pre>
          </div>
        </div>

        <div class="nested-block">LIKE, ORDER BY (ASC, DESC)
          <div class="nested-content">
            <p>Сортировка</p> 
<pre><code>
SELECT author, title FROM book
WHERE amount >= 2 AND amount <= 14
ORDER BY author DESC, title;
</code></pre>
            <p>LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение),
               а в соответствии с шаблоном.           </p>
            <p>% - ноль или более символов</p> 
            <p>_ - один символ</p> 
<pre><code>
  SELECT title, author FROM book
  WHERE title LIKE "_% _%" AND author LIKE "%С.%"
  ORDER BY title
</code></pre>
            <p>LIKE "_% _%" - 2 слова в title</p> 
            <p>LIKE "%С.%" - инициалы С. в author</p>  
          </div>
        </div>

        <div class="nested-block">ГУППОВЫЕ (АГРЕГИРУЮЩИЕ): DISTINCT, SUM, COUNT, MIN, MAX, AVG, HAVING
          <div class="nested-content">
            <p>Выбирает уникальные значения amount</p>
<pre><code>
SElECT DISTINCT amount FROM book
</code></pre>
            <p>Группирует по author, суммирует amount, и показывает количество amount в группе</p>
<pre><code>
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
</code></pre>
            <p>Считает мин мах и среднюю цену в группе</p>
<pre><code>
SELECT author, MIN(price) Минимальная_цена, MAX(price) Максимальная_цена, AVG(price) Средняя_цена
FROM book
GROUP BY author; 
</code></pre>
            <p>Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. </p>
<pre><code>
SELECT author,
MIN(price) AS Минимальная_цена,
MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
</code></pre>
          </div>
        </div>

        <div class="nested-block">ОБНОВЛЕНИЕ: UPDATE
          <div class="nested-content">
            <p>измнить все записи в солонке</p>
<pre><code>
UPDATE book 
SET price = 0.7 * price;
</code></pre>
            <p>Удалить из таблицы supply все книги, названия которых есть в таблице book.</p>
<pre><code>
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );
</code></pre>
          </div>
        </div>

        <div class="nested-block">СОЕДИНЕНИЕ: INNER JOIN, LEFT\RIGHT\OUTER ,USING
          <div class="nested-content">
            <p>Таблица "Customers" (Заказчики):</p>
<pre><code>
| CustomerID| CustomerName| Country  |
+-----------+-------------+----------+
| 1         | John        | USA      |
| 2         | Emily       | UK       |
| 3         | Maria       | Germany  |
</code></pre>
            <p>Таблица "Orders" (Заказы):</p>
<pre><code>
| OrderID  | CustomerID | Total |
+----------+------------+-------+
| 101      | 1          | 150   |
| 102      | 1          | 200   |
| 103      | 2          | 50    |
| 104      | 3          | 300   |
  </code></pre>

            <p>INNER JOIN соединяет две таблицы</p>
<pre><code>
SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;

| OrderID  | CustomerName|
+----------+-------------+
| 101      | John        |
| 102      | John        |
| 103      | Emily       |
| 104      | Maria       |
</code></pre>

<p>LEFT JOIN возвращает все строки из левой таблицы и только те строки из правой таблицы,
   которые соответствуют условию JOIN. Если в правой таблице нет совпадений, 
   будут возвращены значения NULL для полей из правой таблицы.</p>
<pre><code>
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
  
| CustomerName| OrderID  |
+-------------+----------+
| John        | 101      |
| John        | 102      |
| Emily       | 103      |
| Maria       | 104      |
</code></pre>

<p>FULL OUTER JOIN возвращает все строки из обеих таблиц, соответствующие условию JOIN. 
  Если нет совпадений в одной из таблиц, будут возвращены значения NULL для соответствующих полей.</p>
<pre><code>
SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
 
| CustomerName| OrderID  |
+-------------+----------+
| John        | 101      |
| John        | 102      |
| Emily       | 103      |
| Maria       | 104      |
|null         | 105      |
</code></pre>

<p>USING позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. 
  Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, 
  как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), 
  тогда можно использовать предложение USING для реализации операции JOIN.
  author INNER JOIN book   USING(author_id); </p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>


      </div>
    </div>

    <div class="block">БД, SQL

      <div class="content">

        <div class="nested-block">БД, СУБД, типы
          <div class="nested-content">
            <p>БД (база данных) - это организованная коллекция данных, которая хранится и управляется в
              структурированном формате.</p>
            <p>СУБД (система управления базами данных) - это программное обеспечение, которое обеспечивает управление и
              обработку данных в базе данных. С</p>
            <ul>Реляционные СУБД (RDBMS): Это самый распространенный тип СУБД. Он использует модель реляционных таблиц
              для хранения данных. В реляционных СУБД данные представляются в виде таблиц с рядами и столбцами, а между
              таблицами устанавливаются связи. </г>
              <ul>Документоориентированные СУБД: Этот тип СУБД хранит данные в формате документов, обычно в формате JSON
                или BSON.</ul>
              <ul>Ключ-значение (Key-Value) СУБД: В этом типе СУБД данные хранятся в виде пар ключ-значение. </ul>
              <ul>Колоночные СУБД: Колоночные СУБД хранят данные в виде колонок, вместо строк, как это делается в
                реляционных СУБД. Это позволяет более эффективно хранить данные и улучшает производительность для
                операций чтения. Примеры: Apache Cassandra, HBase.</ul>
              <ul>Временные ряды СУБД: Этот тип СУБД предназначен для работы с данными временных рядов, такими как
                данные датчиков, логи, статистика и т. д. Они оптимизированы для работы с временными метками данных и
                обеспечивают высокую скорость вставки и извлечения данных. Примеры: InfluxDB, TimescaleDB.</ul>
          </div>
        </div>

        <div class="nested-block">операторы SQL?
          <div class="nested-content">
            <p>операторы определения данных (Data Definition Language, DDL):</p>
            <ul>CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),</ul>
            <ul>ALTER изменяет объект,</ul>
            <ul>DROP удаляет объект;</ul>
            <p>операторы манипуляции данными (Data Manipulation Language, DML):</p>
            <ul>SELECT выбирает данные, удовлетворяющие заданным условиям,</ul>
            <ul>INSERT добавляет новые данные,</ul>
            <ul>UPDATE изменяет существующие данные,</ul>
            <ul>DELETE удаляет данные;</ul>
            <p>операторы определения доступа к данным (Data Control Language, DCL):</p>
            <ul>GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,</ul>
            <ul>REVOKE отзывает ранее выданные разрешения,</ul>
            <ul>DENY задает запрет, имеющий приоритет над разрешением;</ul>
          </div>
        </div>

        <div class="nested-block">«представление» (view) и для чего оно применяется?
          <div class="nested-content">
            <p>Представление, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным
              образом.
              В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в
              структуре памяти, напоминающей SQL таблицу. </p>
          </div>
        </div>

        <div class="nested-block">первичный ключ?
          <div class="nested-content">
            <p>RIMARY KEY предназначен для однозначной идентификации каждой записи в таблице и является строго
              уникальным (UNIQUE): две записи таблицы не могут иметь одинаковые значения первичного ключа. Нулевые
              значения (NULL) в PRIMARY KEY не допускаются.
              Если в качестве PRIMARY KEY используется несколько полей, их называют составным ключом.</p>
          </div>
        </div>

        <div class="nested-block">внешний ключ?
          <div class="nested-content">
            <p>FOREIGN KEY также является атрибутом ограничения и обеспечивает связь двух таблиц.
              По сути, это поле или несколько полей, которые ссылаются на PRIMARY KEY в родительской таблице.</p>
          </div>
        </div>

        <div class="nested-block">ограничения (constraints)
          <div class="nested-content">
            <p>UNIQUE — гарантирует уникальность значений в столбце;</p>
            <p>NOT NULL — значение не может быть NULL;</p>
            <p>INDEX — создаёт индексы в таблице для быстрого поиска/запросов;</p>
            <p>CHECK — значения столбца должны соответствовать заданным условиям;</p>
            <p>DEFAULT — предоставляет столбцу значения по умолчанию.</p>
          </div>
        </div>

       

        <div class="nested-block">четыре основных типа соединения в SQL JOIN
          <div class="nested-content">
            <p>1 INNER JOIN выбирает только те строки, которые имеют соответствующие значения в обеих таблицах </p>
            <p>SELECT * FROM table1</p>
            <p>INNER JOIN table2</p>
            <p>ON table1.column = table2.column;</p>
            <p> LEFT JOIN возвращает все строки из левой таблицы и только соответствующие строки из правой таблицы. Если
              нет соответствующих значений в правой таблице, будут возвращены NULL-значения.</p>
            <p>SELECT *
              FROM table1</p>
            <p>LEFT JOIN table2</p>
            <p>ON table1.column = table2.column;</p>
            <p>Чтобы выбрать только из левой таблицы добавить</p>
            <p>Where table2.key is NULL </p>
            <p> RIGHT JOIN возвращает все строки из правой таблицы и только соответствующие строки из левой таблицы.
            </p>
            <p>FULL OUTER JOIN — объединяет записи из обеих таблиц (если условие объединения равно true)
              и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений.
              Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.
            </p>
          </div>
        </div>

        <div class="nested-block"> основные агрегатные функции.
          <div class="nested-content">
            <p>COUNT - производит подсчет записей, удовлетворяющих условию запроса</p>
            <p>SUM - вычисляет арифметическую сумму всех значений колонки;</p>
            <p>AVG - вычисляет среднее арифметическое всех значений</p>
            <p>MAX - определяет наибольшее из всех выбранных значений; MIN - определяет наименьшее из всех выбранных
              значений.</p>
          </div>
        </div>

        <div class="nested-block">IN, BETWEEN, LIKE?
          <div class="nested-content">
            <p>IN - определяет набор значений.</p>
            <p>SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');</p>
            <p>BETWEEN определяет диапазон значений.</p>
            <p>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;</p>
            <p>LIKE применим только к полям типа CHAR или VARCHAR</p>
            <p>_ замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не
              будет соответствовать 'brat'.</p>
            <p>% замещает последовательность любого числа символов. </p>
            <p>SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';</p>
          </div>
        </div>

        <div class="nested-block"> Self JOIN?
          <div class="nested-content">
            <p>Это выражение используется для того, чтобы таблица объединилась сама с собой, словно это две разные
              таблицы.</p>
            <p>Чтобы такое реализовать, одна из таких «таблиц» временно переименовывается.</p>
          </div>
        </div>

        <div class="nested-block">оператор UNION?
          <div class="nested-content">
            <p>Он используется для объединения полученных данных из двух или более запросов,
              которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в том же
              порядке.</p>
          </div>
        </div>

        <div class="nested-block">псевдонимы Aliases
          <div class="nested-content">
            <p>SQL-псевдонимы нужны для того, чтобы дать временное имя таблице или столбцу.
              Это нужно, когда в запросе есть таблицы или столбцы с неоднозначными именами.</p>
          </div>
        </div>

        <div class="nested-block">Как найти дубли в поле email?
          <div class="nested-content">
            <p>SELECT email, COUNT(email)</p>
            <p>FROM customers</p>
            <p>GROUP BY email</p>
            <p>HAVING COUNT(email) > 1;</p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">JDBC

      <div class="content">

        <div class="nested-block">JDBC
          <div class="nested-content">
            <p>JDBC, Java DataBase Connectivity (соединение с базами данных на Java)
              — промышленный стандарт взаимодействия Java-приложений с различными СУБД.
              Реализован в виде пакета java.sql, входящего в состав Java SE.</p>
          </div>
        </div>

        <div class="nested-block"> JDBC URL?
          <div class="nested-content">
            <p> protocol: (протокола) - всегда jdbc:.</p>
            <p>(подпротокола) - это имя драйвера или имя механизма соединения с базой данных.</p>
            <p>подымя - //<hostname>:<port>/<subsubname.< /p>
                    <p>jdbc:mysql://localhost:3306/Test</p>
          </div>
        </div>

        <div class="nested-block">Из каких частей стоит JDBC?
          <div class="nested-content">
            <p>JDBC API, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и
              методы объявлены в двух пакетах - java.sql и javax.sql;</p>
            <p>JDBC-драйвер, компонент, специфичный для каждой базы данных.</p>
          </div>
        </div>

        <div class="nested-block">основные классы и интерфейсы JDBC.
          <div class="nested-content">
            <p>java.sql.DriverManager - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем
              получить соединение с базой данных.</p>
            <p>java.sql.Connection - обеспечивает формирование запросов к источнику данных и управление транзакциями.
            </p>
            <p>java.sql.Statement , java.sql.PreparedStatement и java.sql.CallableStatement - эти интерфейсы позволяют
              отправить запрос к источнику данных.</p>
            <p>java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по набору данных и считывать
              значения отдельных полей в текущей записи.</p>
          </div>
        </div>

        <div class="nested-block">основные этапы работы с базой данных при использовании JDBC.
          <div class="nested-content">
            <p>Регистрация драйверов;</p>
            <p>Установление соединения с базой данных;</p>
            <p>Создание запроса(ов) к базе данных;</p>
            <p>Выполнение запроса(ов) к базе данных;</p>
            <p>Обработка результата(ов);</p>
            <p>Закрытие соединения с базой данных.</p>
            <p></p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

    <div class="block">MONGO DB

      <div class="content">

        <div class="nested-block">ЧТо это
          <div class="nested-content">
            <p>документо-ориентированную систему управления базами данных</p>
            <p>Коллекция - это аналог таблицы в реляционных базах данных. Она содержит группу документов.</p>
            <p>Документ - это запись, представляющая собой JSON-подобный объект. В документе могут храниться различные поля с данными.</p>
            <p> Каждый документ в коллекции может иметь разные поля, и схему можно изменять без необходимости изменения существующих документов.</p>
            <img src="images/mondoDbStructure.png" alt="mongo db">
          </div>
        </div>

        <div class="nested-block">ДОБАВЛЕНИЕ
          <div class="nested-content">
            <p>db.users.insertOne({"name": "Tom", "age": 28, "languages": ["english", "spanish"]})</p>
            <p>insertMany(): добавляет несколько документов</p>
            <p>db.users.find()</p>
          </div>
        </div>

        <div class="nested-block">ПОИСК
          <div class="nested-content">
            <p>db.users.find({name: "Tom"}) - найдет все документы с такой записью</p>
            <p>db.users.find({languages: null}) - документы, где свойство languages не определено.</p>
            <p>function sqrt(n) { return n*n; } db.users.find({age: sqrt(5)+3})  - JS выражения</p>
            <p>db.users.findOne({name: "Tom"}) - найдет один документ</p>
            <p>Результат выборки, получаемой с помощью функции find, называется курсором. При необходимости мы можем передать курсор в отдельную переменную:  </p>
<pre><code>
  var cursor = db.users.find()
 
while(cursor.hasNext()){
  obj = cursor.next();
  print(obj["name"]);
}
</code></pre> 
          </div>
        </div>

        <div class="nested-block">ФИЛЬТРАЦИЯ, ИНДЕКСЫ
          <div class="nested-content">
            <p>db.users.find().limit(3)</p>
            <p>db.users.find().skip(3)</p>
            <p>db.users.find().sort({name: 1})</p>
            <p>Индексы позволяют упорядочить данные по определенному полю, что впоследствии ускорит поиск</p>
            <p>	db.users.createIndex({"name" : 1})</p>
            <p>	db.users.getIndexes() - получить все индексы</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">Агрегатные функции
          <div class="nested-content">
            <p>	db.users.countDocuments()</p>
            <p>	db.users.find({name: "Tom"}).count()</p>
            <p>db.users.find({name: "Tom"}).skip(2).count(true)</p>
            <p> db.users.distinct("name") - уникальные значения поля name</p>
            <p>db.users.find().min({age:30}).hint({age:1})</p>
          </div>
        </div>

        <div class="nested-block">Условные операторы
          <div class="nested-content">
            <p>$eq (равно)</p>
            <p>$ne (не равно)</p>
            <p>$gt (больше чем)</p>
            <p>$lt (меньше чем)</p>
            <p>$gte (больше или равно)</p>
            <p>$lte (меньше или равно)</p>
            <p>$in определяет массив значений, одно из которых должно иметь поле документа</p>
            <p>$nin определяет массив значений, которые не должно иметь поле документа</p>
          </div>
        </div>

        <div class="nested-block">Обновление и удаление данных
          <div class="nested-content">
            <p>db.users.replaceOne({name: "Bob"}, {name: "Bob", age: 25})</p>
            <p>Для обновления отдельных полей в этих функциях применяется оператор $set. Если документ не содержит обновляемое поле, то оно создается</p>
            <p>db.users.updateOne({name : "Tom", age: 22}, {$set: {age : 28}})</p>
            <p>Для удаления отдельного ключа используется оператор $unset:</p>
            <p>	
              db.users.updateOne({name : "Tom"}, {$unset: {salary: 1}})</p>
            <p>Оператор $push позволяет добавить еще одно значение к уже существующему. Например, если ключ в качестве значения хранит массив:</p>
            <p>db.users.updateOne({name : "Tom"}, {$push: {languages: "russian"}})</p>
            <p>db.users.deleteOne({name : "Tom"}) -УДАЛИТ  первый документ</p>
            <p>db.users.deleteMany({name : "Tom"}) - УДАЛИТ все</p>
            <p></p>
          </div>
        </div>

      </div>
    </div>


  </div>

  <div id="block-6" class="block content">

    <div class="block">Операции

      <div class="content">

        <div class="nested-block">Отмена
          <div class="nested-content">
            <p>untracked, unmodified, modified, staged A - B - C</p>
            <p>reset --soft B есть изменения из коммита C они индексе</p>
            <p>reset --mixed B У нас есть все изменения из С, они не в индексе</p>
            <p>reset --hard B нет изменений из С</p>
            <p>restore --staged FILE Убрать файл из индексации</p>
            <p>restore FILE Отменить изменения в файле</p>
            <p>git revert [commit SHA] создается отменяющий коммит</p>
          </div>
        </div>


        <div class="nested-block">Удаление
          <div class="nested-content">
            <p>rm --cached README Удалить файл из индекса, оставив его при этом в рабочем каталоге</p>
            <p>mv file_from file_to Как переименовать файл</p>
            <p>branch -d mergBR Удалить слитую ветку (merged)</p>
            <p>branch -D noMergBr Удалить не слитую ветку со всеми изменениями</p>
            <p>push origin -d branchForDelete Удалить удаленную ветку</p>
          </div>
        </div>

        <div class="nested-block">Просмотр
          <div class="nested-content">
            <p>git branch -a</p>
            <p>git branch -a показать все ветки</p>
            <p>git branch --merged список вмерженных в в текущую</p>
            <p>git branch --merged master список вмерженных в мастер</p>
            <p>git branch --no-merged посмотреть неслитые ветки (git branch --no-merged)</p>
            <p>git remote show origin посмотреть удаленные ветки в репозитории</p>
            <p>log Просмотр истории</p>
            <p>git log --name-status COMMIT_HASH Как найти список файлов, которые изменились в определенном коммите?</p>
            <p>remote -v Просмотреть адреса репозиториев для чтения и записи</p>
          </div>
        </div>

        <div class="nested-block">Переименование
          <div class="nested-content">
            <p>branch --move OLD NEW Переименовать ветку</p>
            <p>push --set-upstream origin NEW Переименовать удаленную ветку</p>
            <p>push origin --delete OLD </p>
            <p>remote rename pb paul Переименование и Удаление удалённых репозиториев</p>
            <p>remote remove paul </p>
          </div>
        </div>

        <div class="nested-block">Псевдонимы, теги
          <div class="nested-content">
            <p>config --global alias.unstage 'reset HEAD --' Псевдоним, исключении файла из индекса </p>
            <p>config --global alias.last 'log -1 HEAD' Псевдоним, просмотреть последний коммит </p>
            <p></p>tag -a v1.4 -m "v1.4" аннотированные хранятся в бд Git как объекты. содержат имя автора, его e-mail и
            дату создания, имеют комментарий </p>
            <p></p>tag v1.4-lw легковесный </p>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="block-7" class="block content">

    <div class="block">Core

      <div class="content">

        <div class="nested-block">Типы данных JS
          <div class="nested-content">
            <p>1. Число (Number)</p>
            <p>2. String</p>
            <p>3. Boolean </p>
            <p>4. Массив (Array)</p>
            <p>5. Объект (Object)</p>
            <p>6. Undefined - не определено</p>
            <p>7. Null - пустое</p>
            <p>8. Символ (Symbol)</p>
            <p>9. Функция (Function)</p>
          </div>
        </div>

        <div class="nested-block">Как проверить является ли объект массивом?
          <div class="nested-content">
            <p>
            <p>Array.isArray(obj1)</p>
            </p>
          </div>
        </div>

        <div class="nested-block">Как проверить, является ли число конечным?
          <div class="nested-content">
            <p>isFinite() (вернет true)
            </p>
          </div>
        </div>

        <div class="nested-block">Как проверить, что переменная равна NaN?
          <div class="nested-content">
            <p>isNan() (вернет true)</p>
          </div>
        </div>

        <div class="nested-block">Чем отличается поведение isNaN() и Number.isNaN()?
          <div class="nested-content">
            <p>Метод isNaN() используется для проверки, является ли значение нечисловым (NaN).
              Однако, переданное значение будет автоматически преобразовано в число, если оно не является числом, перед
              выполнением проверки. Это означает, что метод isNaN() может вернуть true для некоторых значений, которые
              не являются NaN,
              например, для строк или пустых значений.
            </p>
          </div>
        </div>

        <div class="nested-block">var / let / const
          <div class="nested-content">
            <p> var, имеет функциональную область видимости или область видимости внутри блока кода,
              в котором она объявлена.
              Это означает, что переменная var доступна за пределами блока, в котором она объявлена,
              если она не объявлена внутри функции.
            </p>
            <p>
              Переменная, объявленная с помощью let, имеет область видимости внутри блока,
              в котором она объявлена, также известную как лексическая область видимости.
              Это означает, что переменная let не доступна за пределами блока, в котором
              она объявлена.
            </p>
            <p>
              Переменная, объявленная с помощью const, также имеет блочную область
              видимости и должна быть инициализирована при объявлении.
              Значение const переменной не может быть переназначено после инициализации,
              но сам объект или массив, на который ссылается const переменная, может быть изменен.
            </p>
          </div>
        </div>

        <div class="nested-block">Что такое область видимости?
          <div class="nested-content">
            <p>Global Scope доступны из любой части программы</p>
            <p>Local Scope внутри фунцкии, цикла и тд</p>
            <p>Block Scope введена в ES6</p>
          </div>
        </div>

        <div class="nested-block">Что такое деструктуризация
          <div class="nested-content">
            <p>Деструктуризация (Destructuring) в программировании
              - это способ извлечь значения из массивов или объектов и присвоить их переменным с помощью более
              компактного синтаксиса
              Введена с ES6
            </p>
          </div>
        </div>

        <div class="nested-block">Замыкание (closure)
          <div class="nested-content">
            <p>когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том
              случае, когда она выполняет вне своей области видимости.</p>
            <p>Замыкание технически включает три компонента:</p>
            <ul>внешняя функция, в которой определены некоторые переменные - лексическое окружение</ul>
            <ul>переменные (лексическое окружение), которые определены во внешней функции</ul>
            <ul>вложенная функция, которая использует эти переменные</ul>
          </div>
        </div>

        <div class="nested-block">Что такое деструктуризация
          <div class="nested-content">
            <p> </p>
          </div>
        </div>

      </div>
    </div>

  </div>

  <div id="block-8" class="block content">
    <div class="block">Selenium
      <div class="content">

        <div class="nested-block">Локаторы
          <div class="nested-content">
            <p>ID, Name, Class Name, Tag Name, Link Text </p>

            <p>По CSS Selector </p>
            <ul> (id): Выбирает элементы по их уникальному идентификатору.
              Пример: driver.findElement(By.cssSelector("#myElementId"));</ul>
            <ul>class: By.cssSelector(".myClass")</ul>
            <ul>attribute: By.cssSelector("[name='username']")</ul>
            <ul>tag name: By.cssSelector("div")</ul>
            <ul>По иерархии: descendant By.cssSelector("div > p")</ul>
            <ul>pseudo-classes: (By.cssSelector("input[type='checkbox']:checked")</ul>
            <ul>По комбинированным условиям: By.cssSelector("input.myClass[name='username'][type='text']"))</ul>
            <p>Приемущества:</p>
            <ul>Производительность: CSS-локаторы обычно более быстрые и эффективные в поиске элементов на странице, чем
              XPath</ul>
            <ul>Поддержка браузерами: CSS-локаторы поддерживаются всеми браузерами, xpath может быть некорректно в IE
            </ul>
            <ul>Простота и краткость? Легче читаемы</ul>
            <ul>Поддержка псевдоклассов</ul>

            <p>По XPath - XML Path Language Оси</p>

            <ul>ancestor:: — возвращает множество предков.</ul>
            <ul>ancestor-or-self:: — возвращает множество предков и текущий элемент</ul>
            <ul>child:: — возвращает множество потомков на один уровень ниже.</ul>
            <ul>descendant:: — возвращает полное множество потомков.</ul>
            <ul>following:: — возвращает необработанное множество, ниже текущего элемента.</ul>
            <ul>following-sibling:: — возвращает множество элементов на том же уровне, следующих за текущим.</ul>
            <ul>parent:: — возвращает предка на один уровень назад.</ul>
            <ul>preceding:: — возвращает множество обработанных элементов исключая множество предков.</ul>
            <ul>preceding-sibling:: — возвращает множество элементов на том же уровне, предшествующих текущему.</ul>
            <ul></ul>

          </div>
        </div>

        <div class="nested-block"> WAITS
          <div class="nested-content">
            <p>ожидания (Wait) представляют собой механизм, который позволяет автоматизированным тестам дожидаться
              определенных условий перед выполнением следующего действия. </p>
            <p>Неявные задаются один раз и автоматически применяются к каждой команде поиска элемента
              driver.manage().timeouts().implicitlyWait()
            </p>
            <p>Явные ожидания используются для ожидания определенного условия перед выполнением следующего действия.
            </p>
            <p>
              Fluent Wait (Плавающее ожидание) - это подтип явного ожидания (Explicit Wait),
              который предоставляет более гибкий и удобный способ настройки ожиданий в тестах. Он позволяет
              устанавливать несколько условий ожидания для одного элемента и выполнять дополнительные действия, когда
              условие не выполнено.</p>
            <p>FluentWait<WebDriver> wait = new FluentWait<>(driver)</p>
            <p> .withTimeout(Duration.ofSeconds(30))</p>
            <p>.pollingEvery(Duration.ofSeconds(5))</p>
            <p>.ignoring(NoSuchElementException.class)</p>
            <p>WebElement element = wait.until(ExpectedConditions.elementToBeClickable(By.id("myElement")))</p>
            <p></p>
            <p></p>


          </div>
        </div>

        <div class="nested-block">Приемущества css перед xpath
          <div class="nested-content">
            <p>Простота и краткость</p>
            <p>Производительность</p>
            <p>Поддержка в браузерах</p>
            <p>Знания в CSS пригодятся вам не только для автоматизации с Selenium, но и для стилизации веб-страниц</p>
            <p>Поддержка псевдоэлементов и псевдоклассов</p>
            <p></p>
          </div>
        </div>

        <div class="nested-block">pageLoadStrategy
          <div class="nested-content">
            <p>normal - ожидается document.readyState (default)</p>
            <p>eager - доступ к DOM готов,но ресурсы все еще могут загружаться (картинки)</p>
            <p>none - при переходе на новую страницу нет ожидания загрузки DOM</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p>ByCssSelector extends By.BaseW3CLocator</p>
            <p>ByXPath extends By.BaseW3CLocator</p>
            <p>ByTagName extends By.BaseW3CLocator</p>
            <p>ByPartialLinkText extends By.BaseW3CLocator</p>
            <p>ByLinkText extends By.BaseW3CLocator</p>
            <p>ByName extends By.PreW3CLocator</p>
            <p>ByClassName extends By.PreW3CLocator</p>     
            <p>ById extends By.PreW3CLocator</p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">
            <p></p>
          </div>
        </div>

      </div>
    </div>

  </div>

  <div id="block-9" class="block content">
    <div class="block">DOCKER, LINUX
      <div class="content">

        <div class="nested-block">DOCKER COMMANDS
          <div class="nested-content">
            <p>Создание и управление контейнерами:</p>
              <ul>docker run: Создание и запуск нового контейнера на основе определенного образа.
                Пример: docker run -d -p 80:8080 --name my-container my-image</ul>
              <ul>docker start: Запуск остановленного контейнера.</ul>
              <ul>docker stop: Остановка выполняющегося контейнера.</ul>
              <ul>docker restart: Перезапуск контейнера.</ul>
              <ul>docker run -e MYSQL_USER=user -e MYSQL_PASSWORD=pass mysql Установка переменных окружения при запуске контейнера.</ul>
            <p>Просмотр и мониторинг контейнеров</p>
              <ul>docker ps: Просмотр выполняющихся контейнеров.</ul>
              <ul>docker ps -a: Просмотр всех контейнеров (включая остановленные).</ul>
              <ul>docker logs: Просмотр логов контейнера.</ul>
              <ul>docker stats: Мониторинг использования ресурсов контейнерами.</ul>
              <ul> docker inspect stupefied_turing - подробная инфа</ul>
            <p>Работа с образами</p>
              <ul>docker images: Просмотр списка доступных образов.</ul>
              <ul>docker pull: Загрузка образа из Docker Hub.</ul>
              <ul>docker build -t my-image . - Сборка Docker образа на основе Dockerfile.</ul>
              <ul>docker push: Загрузка собранного образа в Docker Hub (требуется авторизация).</ul>
            <p>Удаление ресурсов</p>
              <ul>docker rm -v - удалить все остановленные контейнеры</ul>
              <ul>docker rmi: Удаление образа.</ul>
              <ul>docker image prune: Удаление неиспользуемых образов.</ul>
            <p>Работа с сетями</p>
              <ul>docker network create: Создание пользовательской сети.</ul>
              <ul>docker network connect: Присоединение контейнера к сети.</ul>
              <ul>docker network disconnect: Отсоединение контейнера от сети.</ul>
            <p>Управление Docker Compose:</p>
              <ul>docker-compose up: Запуск приложения, описанного в файле docker-compose.yml.</ul>
              <ul>docker-compose down: Остановка и удаление контейнеров из docker-compose.yml.</ul>
            <p>Работа с файловой системой контейнера:</p>
              <ul>docker cp file.txt my-container:/path/to/destination копирование файлов между хостовой системой и контейнером.</ul>
              <ul>docker exec -it my-container bash Выполнение команды внутри запущенного контейнера</ul>
            <p>Управление хранилищем данны</p>
              <ul>docker volume create: Создание Docker Volume для хранения данных.</ul>
              <ul>docker volume ls: Просмотр списка созданных Docker Volume.</ul>
              <ul>docker volume rm: Удаление Docker Volume.</ul>
          </div>
        </div>

        <div class="nested-block">Docker BASE
          <div class="nested-content">
            <p>Docker - это платформа для разработки, доставки и выполнения приложений в контейнерах. 
              Основное преимущество Docker перед виртуализацией заключается в более легковесной и 
              эффективной изоляции приложений. Вместо полной виртуализации ОС,
              Docker использует общее ядро ОС хоста для запуска контейнеров, что делает их быстрее и более эффективными.</p>
            <p>Контейнер в Docker - это легковесное и изолированное окружение, включающее в себя приложение и его зависимости,
               которое может быть выполнено практически в любой среде. Преимущества контейнеризации включают консистентность окружения, 
              быстрое развертывание, изолированность ресурсов, удобство масштабирования и более эффективное использование ресурсов.</p>
              <p>Для создания, запуска и управления контейнерами в Docker отвечает Docker Engine. Это ядро Docker-платформы, которое включает в себя сервер Docker (dockerd) и клиентский инструмент (docker).</p>
            <p>Docker образы состоят из нескольких слоев, где каждый слой представляет собой изменение в файловой системе. Контейнеры запускаются из Docker образов. Образ является основой контейнера, 
              и каждый контейнер состоит из своего слоя файловой системы (на верхнем уровне) и слоев образа (нижние уровни).</p>  
            <p>Docker поддерживает несколько типов сетей: bridge, host, overlay и none. Сетевые режимы включают bridge (создание собственной сети контейнеров), 
              host (использование сети хоста), overlay (использование в оркестрации) и none (отсутствие сети).</p>  
            <p>Docker Volume - это механизм, который позволяет создавать и управлять персистентным хранилищем данных для контейнеров. 
              Данные в Docker Volume сохраняются даже после удаления контейнера, что обеспечивает долгосрочное хранение.
              анные в Docker Volume изолированы от контейнеров, что обеспечивает безопасное и надежное хранение.
            </p>  
            <p>Docker Swarm - это интегрированная оркестрационная платформа для управления контейнерами Docker. Он позволяет создавать и управлять кластером Docker, включая автоматическое масштабирование, 
              балансировку нагрузки и другие функции, обеспечивая упрощенную оркестрацию и управление контейнерами.</p>  
            <p>В качестве альтернатив Docker Compose и Docker Swarm существуют другие инструменты, такие как Kubernetes (K8s) и Apache Mesos. Kubernetes - это мощная система оркестрации, предоставляющая более широкий набор функций для управления контейнерами и приложениями в масштабе.</p>  
            <p>Для оптимизации размера Docker образов вы можете использовать следующие методы:

              Удаление ненужных файлов и зависимостей.
              Использование минимальных базовых образов (Alpine Linux, BusyBox и т. д.).
              Оптимизация команд в Dockerfile для уменьшения количества слоев.
              Использование мульти-стадийных сборок для создания минимальных образов для выполнения.
              Очистка кэша и временных файлов внутри образов.</p>
            <p>Для мониторинга и управления производительностью Docker контейнеров вы можете использовать инструменты, такие как Prometheus, Grafana, Docker Stats, cAdvisor и Docker Compose</p>
            
            <img src="images/dockerVSvirtualMachine.png" alt="dockerVSvirtualMachine">
          </div>
        </div>

        <div class="nested-block">DOCKERFILE
          <div class="nested-content">
            <p> это текстовый файл, содержащий инструкции и команды для автоматической сборки Docker-образа.</p>
            <p>Каждая команда - отдельный слой образа</p>
            <ul>FROM ubuntu:20.04 Определяет базовый образ, на основе которого будет создан новый образ.</ul>
            <ul>WORKDIR /app Устанавливает рабочую директорию для последующих инструкций.</ul>
            <ul>COPY app.py /app  Копирует файлы и директории из хостовой системы в контейнер.</ul>
            <ul>RUN apt-get update && apt-get install -y curl Выполняет команды внутри контейнера во время сборки образа.</ul>
            <ul>ENV PORT=80 Устанавливает переменные окружения в контейнере</ul>
            <ul>EXPOSE 8080  Объявляет порт, на котором контейнер будет слушать во время выполнения.</ul>
            <ul>CMD ["python", "app.py"] Задает команду, которая будет выполняться при запуске контейнера.</ul>
            <ul>ENTRYPOINT: 
              Определяет выполняемый файл (программу) (и аргументы по умолчанию), запускаемый при инициализации контейнера
              Аналогично CMD, задает команду, но не может быть переопределен командой при запуске</ul>
            <ul>VOLUME: Создает точку монтирования для хранения данных между контейнером и хостовой системой.

              Пример: VOLUME /data</ul>
          </div>
        </div>

        <div class="nested-block">Docker-compose
          <div class="nested-content">
            <p>это инструмент для определения и запуска многоконтейнерных приложений с помощью файла конфигурации в формате YAML</p>
            <ul>docker-compose up -d: Запуск приложения в фоновом режиме (detached mode).</ul>
            <ul>docker-compose down: Остановка и удаление всех контейнеров, сетей и томов, связанных с приложением.</ul>
            <ul>docker-compose build: Сборка Docker-образов для всех сервисов в приложении.</ul>
            <ul>docker-compose config: Проверка и вывод скомпилированной конфигурации </ul>
            <p></p> 
          </div>
        </div>

        <div class="nested-block">LINUX COMMANDS
          <div class="nested-content">
            <p> ls Список файлов и директорий</p>
              <ul>-a: Включение скрытых файлов в вывод.</ul>
              <ul>-h: Человекочитаемые размеры файлов </ul>
              <ul>-l:Отображение детальной информации о файлах.</ul>
              <ul>-S Сортировать результаты по размеру (size)</ul>
            <p>cd: Смена текущей директории.</p>
            <p>pwd: Отображение текущего пути.</p>
            <p>mkdir: Создание новой директории.</p>
            <p>rm</p>
              <ul>-r: Рекурсивное удаление директории.</ul>
              <ul>-f: Принудительное удаление без подтверждения.</ul>
            <p>cp </p>
              <ul>--r: Рекурсивное копирование директории.</ul>
              <ul>-a: со всеми атрибутами, включая идентификаторы владельцев и права доступа (без - стандартные права)</ul>
            <p>mv: Перемещение/переименование файлов или директорий.</p>

            <p>cat: Вывод содержимого файла.  </p>
            <p>less / more: Постраничный просмотр файла.</p>
            <p>nano: Простой текстовый редактор.</p>
            <p>vim / vi: Мощный текстовый редактор.</p>
            <p>grep: Поиск текста в файлах.</p>

            <p> ps — выводит список процессов, выполняющихся в текущий момент</p>
            <p>kill — посылает сигнал процессу.</p>
            <p>printenv - список переменных окружения</p>
            <p>ping — — посылает пакеты</p>
            <p>traceroute — выводит трассировку маршрута пакетов к сетевому узлу.</p>
            <p>ssh — клиент OpenSSH SSH</p>
            <p>netstat — вывод параметров настройки сети и статистик</p>
          </div>
        </div>

        <div class="nested-block">КАТАЛОГИ Linux
          <div class="nested-content">
            <p>/bin Содержит двоичные (binaries) файлы (программы), необходимые для загрузки и функционирования системы</p>
            <p>/boot Содержит ядро Linux</p>
            <p>/dev список всех известных ему устройств</p>
            <p>/etc системные конфигурационные файлы</p>
            <p>/home домашний каталог простых пользователей</p>
            <p>/lib Содержит файлы разделяемых библиотек, используемых основными системными программами</p>
            <p>/opt я для установки «необязательного» (optional) программного обеспечения</p>
            <p>/usr я все программы и файлы поддержки, используемые
              обычными пользователями</p>
          </div>
        </div>

        <div class="nested-block">ЖЕСТКИЕ и СИМВОЛИЧЕСКИЕ ссылки
          <div class="nested-content">
            <p>Жесткая ссылка не может указывать на файл за пределами собственной файловой системы.</p>
            <p>Символическая не имеет таких ограничений</p>
            <p>Если попытаться что-то записать в символическую ссылку, запись будет выполнена в файл, на который она указывает.</p>
            <p>ССылки нужны, чтобы давать простые имена для файлов или каталогов (foo-v.2.3 - версия будет изменяться, а название ссылки нет)</p>
          </div>
        </div>

        <div class="nested-block">Перенаправление вывода
          <div class="nested-content">
            <p>ls -l > directory_listing.txt -  вывод команды ls -l будет записан в файл directory_listing.txt.</p>
            <p>echo "New line of text" >> my_file.txt  - для добавления стандартного вывода в конец файла, сохраняя существующее содержимое файла.</p>
            <p>ls -l non_existent_file 2> error_log.txt  - Команда 2> используется для перенаправления стандартного вывода ошибок </p>
            <p>ls -l non_existent_file &> output_and_errors.txt  - &> используется для перенаправления как стандартного вывода, так и стандартной ошибки в один файл.</p>
            <p>cat my_file.txt | grep "search_term" - Пайплайн (|) позволяет передавать вывод одной команды в качестве ввода другой.
              содержимое файла my_file.txt будет передано на вход команды grep для поиска определенного термина.
            </p>
          </div>
        </div>

        <div class="nested-block">ПРАВА ДОСТУПА
          <div class="nested-content">
            <p>Права на файл, на группу, на всех 777 - полный доступ всем на все</p>
            <p>Восьмеричное Двоичное Режим доступа</p>
            <p>0  000   ---</p>
            <p>1  001   --x</p>
            <p>2  010   -w3 011 -wx</p>
            <p>4  100   r--</p>
            <p>5  101   r-x</p>
            <p>6  110   rw</p>
            <p>7  111 rwx</p>

            <p>useradd <имя_пользователя>: Создание нового пользователя.</p>
            <p>usermod: Изменение параметров пользователя (например, имя, домашний каталог).</p>
            <p>passwd <имя_пользователя>: Установка пароля для пользователя.</p>
            <p>groupadd <имя_группы>: Создание новой группы.</p>
            <p>groupmod: Изменение параметров группы.</p>
            <p>chmod: Изменение прав доступа к файлам и директориям.</p>
            <p>su [-[l]] [пользователь]
              Если указан параметр -l, запущенная командная оболочка станет оболочкой входа для указанного пользователя. </p>
            <p></p>
          </div>
        </div>

      </div>
    </div>

  </div>

  

  <div id="block-10" class="block content">
    <div class="block">Эффективное программирование
      <div class="content">
            
        <div class="nested-block">Типы данных
          <div class="nested-content">
            <p>Ссылочные</p>
              <ul>Интерфейсы ( в т.ч. аннотации)</ul>
              <ul>Классы (в т.ч. Enum)</ul>
              <ul>Массивы</ul>
            <p>Примитивные</p>
          </div>
        </div>

        <div class="nested-block">Приемущества / недостатки статического метода перед конструктором
          <div class="nested-content">
            <p>Приемущества</p>
              <ul>в отличие от конструкторов, он имеет название</ul>
              <ul>static не обязаны при каждом вызове создавать новый объект.</ul>
              <ul>static может возвратить объект, который соответствует не только
                заявленному типу возвращаемого значения, но и любому его подтипу</ul>
            <p>Недсотатки</p>
              <ul> недостаток использования только статических фабричных методов
                заключается в том, что классы, не имеющие открытых или защищённых конструкторов,
                не могут иметь подклассов</ul>
              <ul>их трудно отличить от других статических методов.</ul>
              <ul></ul>
          </div>
        </div>

        <div class="nested-block">Builder
          <div class="nested-content">
            <pre><code>
  public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;
        // Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;
        private int carbohydrate = 0;
        private int sodium = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }
        public Builder calories(int val) {
            calories = val;
            return this;
        }
        public Builder fat(int val) {
            fat = val;
            return this;
        }
        public Builder carbohydrate(int val) {
            carbohydrate = val;
            return this;
        }
        public Builder sodium(int val) {
            sodium = val;
            return this;
        }
        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

public class ClientCode {
  public static void main(String[] args) {
      NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8).
              calories(100).sodium(35).carbohydrate(27).build();

  }
}
            </code></pre>
          </div>
        </div>

        <div class="nested-block">Singleton
          <div class="nested-content">
            <p>первый подход с открытым полем</p>
              <pre>
                <code>
public class Elvis {
  public static final Elvis INSTANCE = new Elvis();
  private Elvis() { }
  public void leaveTheBuilding() { }
}
                </code>
              </pre>
            <p>клиент с расширенными правами
              может запустить закрытый конструктор с помощью рефлексии, вызвав перед этим
              метод AccessibleObject.setAccessible. Если вы хотите защиту от такого рода атаки,
              необходимо изменить конструктор так, чтобы он выбрасывал исключение, если поступит
              запрос на создание второго экземпляра.</p>

            <p>открытый статический фабричный метод: </p>
            <pre>
              <code>
public class Elvis {
private static final Elvis INSTANCE = new Elvis();
private Elvis() { ... }
public static Elvis getInstance() { return INSTANCE; }
public void leaveTheBuilding() { ... }
}                  
              </code>
            </pre>

            <p>преимущество первого подхода (с открытым полем) заключается в том, что из
              объявления класса понятно, что этот класс является синглтоном</p>
            <p>Одно из преимуществ второго подхода (использование статического фабричного
              метода) заключается в том, что он даёт вам возможность отказаться от решения
              сделать класс синглтоном, не меняя при этом его API.</p>

              <pre>
                <code>
                  public enum Elvis {
                    INSTANCE;
                    public void leaveTheBuilding() { ... }
                    }                    
                </code>
              </pre>

              <p>Данный подход функционально эквивалентен подходу с открытым полем, за
                исключением того факта, что он более краток, бесплатно предоставляет механизм
                сериализации и даёт железную гарантию, что не будет создано более одного
                экземпляра, даже в случае замысловатых атак с использованием сериализации или
                рефлексии</p>
          </div>
        </div>

        <div class="nested-block">Контракты переопределения Equals
          <div class="nested-content">
            <ul>• Рефлексивность Для любой ненулевой ссылки х выражение x.equals(x) должно
              возвращать true
            <p>объект должен быть
              равен самому себе</p></ul>
            <ul>Симметричность: Для любых ненулевых ссылок х и у выражение x.equals(y) должно возвращать true тогда и только тогда, когда у.equals(x) возвращает
              true.
            <p>любые два объекта должны сходиться
              во мнении, равны ли они между собой</p></ul>
            <ul>• Транзитивность: Для любых ненулевых ссылок х, у и z, если х.equals(y)
              возвращает true и у.equals(z) возвращает true, то и выражение х.equals(z)
              должно возвращать true
            <p> если один объект равен второму, а второй объект равен третьему, то и первый объект
              должен быть равен третьему объекту.</p></ul>
            <ul>Непротиворечивость: Для любых ссылок х и у, если несколько раз вызвать
              х.equals(y), постоянно будет возвращаться значение true либо постоянно будет
              возвращаться значение false
            <p>если два объекта равны, они должны быть равны все время, пока один из них (или
              оба) не будет изменён</p></ul>
            <ul>Для любой ненулевой ссылки х выражение х.equals(null) должно возвращать
              false
            <p> ни один объект не может быть
              равен null</p></ul>
          </div>
        </div>

        <div class="nested-block">Контракт hashCode
          <div class="nested-content">
              <ul> hashCode должен постоянно возвращать одно и то же целое число</ul>
              <ul>Если объекты равны по equals, то у них одинаковые hashCode</ul>
              <ul>Если объекты имеют одинаковые хэши, то это не значит что они равныe</ul>
              <pre><code>
@Override public int hashCode() {
return Objects.hash(areaCode, prefix, lineNumber);
}                  
              </code></pre>
          </div>
        </div>

        <div class="nested-block">Comparator, Comparable
          <div class="nested-content">

            <pre>
              <code>
public class PhoneNumber implements Comparable&lt;PhoneNumber> {
  private final int areaCode;
  private final int prefix;
  private final int lineNumber;

  private static final Comparator&lt;PhoneNumber> COMPARATOR =
          Comparator.comparingInt((PhoneNumber pn) -> pn.areaCode)
                  .thenComparingInt(pn -> pn.prefix)
                  .thenComparingInt(pn -> pn.lineNumber);

  public PhoneNumber(int areaCode, int prefix, int lineNumber) {
      this.areaCode = areaCode;
      this.prefix = prefix;
      this.lineNumber = lineNumber;
  }

  @Override
  public int compareTo(PhoneNumber phoneNumber) {
      return COMPARATOR.compare(this, phoneNumber);
  }

  @Override
  public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;
      PhoneNumber that = (PhoneNumber) o;
      return areaCode == that.areaCode && prefix == that.prefix && lineNumber == that.lineNumber;
  }

  @Override
  public int hashCode() {
      return Objects.hash(areaCode, prefix, lineNumber);
  }

  @Override
  public String toString() {
      return "(" + areaCode + ") " + prefix + "-" + lineNumber;
  }
}
              </code>

            <p>Демо правильного использования компаратора</p>
          </div>
        </div>

        <div class="nested-block">Композиция вместо наследования
          <div class="nested-content">
            <p>Композиция позволяет добавить новую функциональность</p>
            <p>реализация разделена на две
              части: сам класс и многократно используемый класс переадресации, который содержит
              все методы переадресации и больше ничего:</p>
            <pre>
              <code>
public class InstrumentedSet&lt;E> extends ForwardingSet&lt;E> {
private int addCount = 0;
public InstrumentedSet(Set&lt;E> s) {
super(s);
}
@Override public boolean add(E e) {
addCount++;
return super.add(e);
}
@Override public boolean addAll(Collection&lt;? extends E> c) {
  addCount += c.size();
  return super.addAll(c);
}
public int getAddCount() {
return addCount;
}
} 
              </code>
            </pre>
            <pre><code>
public class ForwardingSet<E> implements Set<E> {
private final Set<E> s;
public ForwardingSet(Set<E> s) { this.s = s; }
public void clear() { s.clear(); }
public boolean contains(Object o) { return s.contains(o); } ...}
            </code></pre>

          </div>
        </div>

        <div class="nested-block">Generics определения
          <div class="nested-content">
            <ul>Параметризованный тип (parameterized type) - List&lt;String></ul>
            <ul>Обобщённый тип (generic type) - List&lt;E></ul>
            <ul>Формальный параметр типа (formal type parameter) - E</ul>
            <ul>Неограниченный подстановочный тип - Listt&lt;?></ul>
            <ul>Сырой тип (raw type) - List</ul>
            <ul>Ограниченный параметр типа
              (bounded type parameter) - &lt;E extends Number></ul>
            <ul>Рекурсивная граница типа - &lt;T extends Comparable<T>> </ul>
            <ul>Ограниченный подстановочный тип (bounded wildcard type) - List<? extends Number></ul>
            <ul>Обобщённый метод - static <E> List<E> asList(E[] a)</ul>
            <ul></ul>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

        <div class="nested-block">
          <div class="nested-content">

            <pre>
              <code>

              </code>
            </pre>
            <p></p>
              <ul></ul>
            <p></p>
          </div>
        </div>

      </div>
    </div>

  </div>


  <script src="scripts/scripts.js"></script>
</body>

</html>